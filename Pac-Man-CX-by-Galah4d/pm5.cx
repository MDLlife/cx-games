package main

/* Function     : reverseDirection
   Input        : Current direction (direction i32)
   Output       : Opposite direction (reverse i32)
   Desctription : Returns the opposite direction of the input.
*/
func reverseDirection(direction i32) (reverse i32) {
  if i32.eq(direction, UP) {
    reverse = DOWN
  }
  if i32.eq(direction, DOWN) {
    reverse = UP
  }
  if i32.eq(direction, LEFT) {
    reverse = RIGHT
  }
  if i32.eq(direction, RIGHT) {
    reverse = LEFT
  }
}

/* Function     : coords2position
   Input        : Vertical board position (line i32)
                : Horizontal board position (collumn i32)
   Output       : A position in the game screen (position graphical2d.Position2D)
   Desctription : Maps a (line/collumn) pair into an actual screen coordinates
*/
func coords2position(line i32, collumn i32) (position graphical2d.Position2D) {
  x := f32.add(-1.0, f32.add(f32.mul(i32.f32(collumn), CELL_WIDTH), f32.div(CELL_WIDTH, 2.0)))
  y := f32.sub(1.0, f32.add(f32.mul(i32.f32(line), CELL_HEIGHT), f32.div(CELL_HEIGHT, 2.0)))

  position = graphical2d.newPosition2D(x, y)
}


/***************************************
 * Ghost behavior functions.
***************************************/

func updateGhostMode(ghost Ghost) () {
  if i32.eq(ghost.status, GHOST_MODE_CHASE) {
    if isTimerOver(GHOST_CHASE_TIMER, GHOST_CHASE_LIMIT) {
      ghosts[ghost.gtype].status = GHOST_MODE_SCATTER
      GHOST_SCATTER_TIMER = glfw.GetTime()
    }
  }

  if i32.eq(ghost.status, GHOST_MODE_SCATTER) {
    if isTimerOver(GHOST_SCATTER_TIMER, GHOST_SCATTER_LIMIT) {
      ghosts[ghost.gtype].status = GHOST_MODE_CHASE
      GHOST_CHASE_TIMER = glfw.GetTime()
    }
  }

  if i32.eq(ghost.status, GHOST_MODE_FRIGHTENED) {
    if isTimerOver(GHOST_FRIGHTENED_TIMER, GHOST_FRIGHTENED_LIMIT) {
      ghosts[ghost.gtype].status = GHOST_MODE_CHASE
      GHOST_CHASE_TIMER = glfw.GetTime()
    }
  }
}

func releaseGhost() {
  for i:=0; i<4; i++ {
    if i32.eq(ghosts[i].status, GHOST_MODE_IN_HOUSE) {
      ghosts[i].index_x = f32.i32(GHOST_SPAWN_COLLUMN)
      ghosts[i].index_y = f32.i32(GHOST_SPAWN_LINE)
      ghosts[i].status = GHOST_MODE_CHASE
      //return;
      break
    }
  }
}

func isTimerOver(timer f64, limit f64) (is_over bool) {
  if gteq(f64.sub(glfw.GetTime(), timer), limit) {
    is_over = true
  }
}


// Collision manager functions

func checkPlayerGhostCollision(ghost Ghost) () {
  if bool.and(i32.eq(player.index_x, ghost.index_x), i32.eq(player.index_y, ghost.index_y)) {
    if i32.eq(ghost.status, GHOST_MODE_FRIGHTENED) {
      ghosts[ghost.gtype].index_x = 14
      ghosts[ghost.gtype].index_y = 13
      ghosts[ghost.gtype].status = GHOST_MODE_IN_HOUSE
    }

    if bool.or(i32.eq(ghost.status, GHOST_MODE_CHASE), i32.eq(ghost.status, GHOST_MODE_SCATTER)) {
      PLAYER_LIVES = i32.sub(PLAYER_LIVES, 1)
      if i32.lteq(PLAYER_LIVES, 0) {
        GAME_OVER = true
        str.print("------ GAME OVER ------") // FIX ME add game over screen
      } else {
        player = newPlayer(PLAYER_SPAWN_LINE, PLAYER_SPAWN_COLLUMN, PLAYER_RADIUS)
      }
    }
  }
}


// Game Object render functions

/* Function     : renderGame
   Input        : OpenGL program (program i32)
   Desctription : Responsible for managing the rendering process of all the game
                  objects.
*/
func renderGame(program i32) () {
  var i i32
  var j i32

  gl.Clear(gl.COLOR_BUFFER_BIT)
  gl.Enable(gl.TEXTURE_2D)
  gl.UseProgram(program)

  renderBoard()  // Render Board
  renderPlayer()    // Render Player

  // Render Points
  for i=0; i<points_count; i++ {
    if bool.eq(points[i].active, true) {
      renderPoint(points[i])
    }
  }

  // Render Ghosts
  for i=0; i<4; i++ {
      renderGhost(ghosts[i])
  }

  renderLives() // Render Lives
  renderLevel()
}

/* Function     : renderBoard
   Desctription : Renders the game board
*/
func renderBoard() () {
  for i:=0; i<y_cells; i++ {
    for j:=0; j<x_cells; j++ {
      graphical2d.drawRectangle(cells[i][j].position, cells[i][j].dimensions, cells[i][j].color)
    }
  }
}

/* Function     : renderPlayer
   Desctription : Renders the player
*/
func renderPlayer() () {
  if isTimerOver(PLAYER_ANIMATION_TIMER, PLAYER_ANIMATION_SEMI_LIMIT) {
    graphical2d.drawPlayer2(player.position, player.radius, player.color)
  } else {
    graphical2d.drawCircle(player.position, player.radius, player.color)
  }

  if isTimerOver(PLAYER_ANIMATION_TIMER, PLAYER_ANIMATION_LIMIT) {
    PLAYER_ANIMATION_TIMER = glfw.GetTime()
  }
}

/* Function     : renderGhost
   Desctription : Renders a ghost
*/
func renderGhost(ghost Ghost) () {
  var color graphical2d.Color

  if i32.eq(ghost.status, GHOST_MODE_FRIGHTENED) {
    if bool.and(isTimerOver(GHOST_ANIMATION_TIMER, GHOST_ANIMATION_SEMI_LIMIT), isTimerOver(GHOST_FRIGHTENED_TIMER, GHOST_FRIGHTENED_SEMI_LIMIT)) {
      color = graphical2d.newColor(1.0, 1.0, 1.0)
    } else {
      color = graphical2d.newColor(0.0, 0.0, 1.0)
    }
  } else {
    color = ghost.color
  }

  if isTimerOver(GHOST_ANIMATION_TIMER, GHOST_ANIMATION_SEMI_LIMIT) {
    graphical2d.drawGhost(ghost.position, ghost.radius, color, 0.5) // FIX ME DrawGhost()
  } else {
    graphical2d.drawGhost(ghost.position, ghost.radius, color, 1.5) // FIX ME DrawGhost2()
  }

  if isTimerOver(GHOST_ANIMATION_TIMER, GHOST_ANIMATION_LIMIT) {
    GHOST_ANIMATION_TIMER = glfw.GetTime()
  }
}

/* Function     : renderPoint
   Desctription : Renders a point
*/
func renderPoint(point Point) () {
  if isTimerOver(POINT_ANIMATION_TIMER, POINT_ANIMATION_SEMI_LIMIT) {
    if i32.eq(point.ptype, PATH_CELL_WITH_SUPER_POINT) {
      graphical2d.drawCircle(point.position, f32.add(point.radius, 0.005), point.color)
    }
    if i32.eq(point.ptype, PATH_CELL_WITH_SIMPLE_POINT) {
      graphical2d.drawCircle(point.position, point.radius, point.color)
    }
  } else {
    graphical2d.drawCircle(point.position, point.radius, point.color)
  }

  if isTimerOver(POINT_ANIMATION_TIMER, POINT_ANIMATION_LIMIT) {
    POINT_ANIMATION_TIMER = glfw.GetTime()
  }
}

/* Function     : renderLives
   Desctription : Renders the player lives
*/
func renderLives() () {
  var color Color
  color = graphical2d.newColor(LIFE_COLOR_RED, LIFE_COLOR_GREEN, LIFE_COLOR_BLUE)

  var position graphical2d.Position2D
  for i:=0; i<PLAYER_LIVES; i++ {
    position = coords2position(LIFE_SPAWN_LINE, i32.sub(LIFE_SPAWN_COLLUMN, i))
    graphical2d.drawLife(position, LIFE_RADIUS, color)
  }
}

func renderLevel() {
  var color Color
  color = graphical2d.newColor(0.0, 0.0, 1.0)

  var position graphical2d.Position2D
  for i:=0; i<GAME_LEVEL; i++ {
    position = coords2position(30, i32.add(1, i))
    graphical2d.drawSkycoin(position, 0.025, 0.0125, color)
  }
}



/***************************************
 * Initialization functions.
***************************************/

/* Function     : initGLFW
   Desctription : Initializes the game window and keyboard input manager.
*/
func initGLFW() () {
  glfw.Init()

  glfw.CreateWindow("window", WIDTH_WINDOW, HEIGHT_WINDOW, "PAC-MAN CX 0.0.3")
  glfw.MakeContextCurrent("window")

	gl.Init()
  gl.Enable(gl.BLEND)
  gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

  glfw.SetKeyCallback("window", "keyboardManager")
}

/* Function     : initOpenGL
   Output       : OpenGL program (program i32)
   Desctription : Initializes the OpenGL program.
*/
func initOpenGL() (program i32) {
	program = gl.CreateProgram()
  gl.LinkProgram(program)
}

/* Function     : initScene
   Desctription : Initializes all game objects including the board cells, the
                  points, the ghosts and the player.
*/
func initScene() () {
  // Initialize game board items
  var line [28]i32
  
  for i:=0; i<y_cells; i++ {
    line = get_board_line(i32.add(i, 1))
    
    for j:=0; j<x_cells; j++ {
      initializeItem(i, j, line[j])
    }
  }

  // Initialize player
  player = newPlayer(PLAYER_SPAWN_LINE, PLAYER_SPAWN_COLLUMN, PLAYER_RADIUS)

  // Initialize ghosts
  ghosts[0] = newGhost(11, 13, 0, GHOST_MODE_CHASE)     // Shadow Ghost
  ghosts[1] = newGhost(14, 11, 1, GHOST_MODE_IN_HOUSE)  // Speedy Ghost
  ghosts[2] = newGhost(14, 13, 2, GHOST_MODE_IN_HOUSE)  // Bashful Ghost
  ghosts[3] = newGhost(14, 15, 3, GHOST_MODE_IN_HOUSE)  // Pokey Ghost
}

func initializeItem(line i32, col i32, item_type i32) () {
  //x := f32.add(-1.0, f32.add(f32.mul(i32.f32(col), CELL_WIDTH), f32.div(CELL_WIDTH, 2.0)))
  //y := f32.sub(1.0, f32.add(f32.mul(i32.f32(line), CELL_HEIGHT), f32.div(CELL_HEIGHT, 2.0)))
  if i32.eq(item_type, WALL_CELL) {
    cells[line][col] = newCell(line, col, WALL_CELL)
  }
  if i32.eq(item_type, PATH_CELL) {
    cells[line][col] = newCell(line, col, PATH_CELL)
  }
  if i32.eq(item_type, PATH_CELL_WITH_SIMPLE_POINT) {
    points[points_count] = newPoint(line, col, PATH_CELL_WITH_SIMPLE_POINT)
    points_count = i32.add(points_count, 1)
    cells[line][col] = newCell(line, col, PATH_CELL)
  }
  if i32.eq(item_type, PATH_CELL_WITH_SUPER_POINT) {
    points[points_count] = newPoint(line, col, PATH_CELL_WITH_SUPER_POINT)
    points_count = i32.add(points_count, 1)
    cells[line][col] = newCell(line, col, PATH_CELL)
  }
  if i32.eq(item_type, TELEPORT_CELL) { // FIX ME merge multiple cases together
    cells[line][col] = newCell(line, col, TELEPORT_CELL)
  }
  if i32.eq(item_type, GATE_CELL) {
    cells[line][col] = newCell(line, col, GATE_CELL)
  }
}

/* Function     : isLevelCompleted
   Output       : true if the level is completed, false otherwise.
   Desctription : Checks if all the points on the board were caught allowing the
                  player to progress to the next level if this condition is met.
*/
func isLevelCompleted() (is_completed bool) {
  is_completed = true
  
  for i:=0; i<points_count; i++Â {
    if points[i].active {
      is_completed = false
    }
  }
}

/* Function     : keyboardManager
   Input        : active window (window str)
                : keyboard key (key i32)
                : scancode (scancode i32)
                : keyboard action (action i32)
                : modifiers (mods i32)
   Desctription : Manages the keyboard inputs.
*/
func keyboardManager(window str, key i32, scancode i32, action i32, mods i32) {
  if bool.and(i32.eq(key, RIGHT_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(RIGHT)
  }
  if bool.and(i32.eq(key, LEFT_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(LEFT)
  }
  if bool.and(i32.eq(key, DOWN_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(DOWN)
  }
  if bool.and(i32.eq(key, UP_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(UP)
  }
}
