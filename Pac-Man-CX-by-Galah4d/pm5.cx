package main

/* Function     : reverseDirection
   Input        : Current direction (direction i32)
   Output       : Opposite direction (reverse i32)
   Desctription : Returns the opposite direction of the input.
*/
func reverseDirection(direction i32) (reverse i32) {
  if i32.eq(direction, UP) {
    reverse = DOWN
  }
  if i32.eq(direction, DOWN) {
    reverse = UP
  }
  if i32.eq(direction, LEFT) {
    reverse = RIGHT
  }
  if i32.eq(direction, RIGHT) {
    reverse = LEFT
  }
}

/* Function     : coords2position
   Input        : Vertical board position (line i32)
                : Horizontal board position (collumn i32)
   Output       : A position in the game screen (position graphical2d.Position2D)
   Desctription : Maps a (line/collumn) pair into an actual screen coordinates
*/
func coords2position(line i32, collumn i32) (position graphical2d.Position2D) {
  x := f32.add(-1.0, f32.add(f32.mul(i32.f32(collumn), CELL_WIDTH), f32.div(CELL_WIDTH, 2.0)))
  y := f32.sub(1.0, f32.add(f32.mul(i32.f32(line), CELL_HEIGHT), f32.div(CELL_HEIGHT, 2.0)))

  position = graphical2d.newPosition2D(x, y)
}


/***************************************
 * Ghost behavior functions.
***************************************/

func updateGhostMode(ghost Ghost) () {
  if i32.eq(ghost.status, GHOST_MODE_CHASE) {
    if isTimerOver(GHOST_CHASE_TIMER, GHOST_CHASE_LIMIT) {
      ghosts[ghost.gtype].status = GHOST_MODE_SCATTER
      GHOST_SCATTER_TIMER = glfw.GetTime()
    }
  }

  if i32.eq(ghost.status, GHOST_MODE_SCATTER) {
    if isTimerOver(GHOST_SCATTER_TIMER, GHOST_SCATTER_LIMIT) {
      ghosts[ghost.gtype].status = GHOST_MODE_CHASE
      GHOST_CHASE_TIMER = glfw.GetTime()
    }
  }

  if i32.eq(ghost.status, GHOST_MODE_FRIGHTENED) {
    if isTimerOver(GHOST_FRIGHTENED_TIMER, GHOST_FRIGHTENED_LIMIT) {
      ghosts[ghost.gtype].status = GHOST_MODE_CHASE
      GHOST_CHASE_TIMER = glfw.GetTime()
    }
  }
}

func releaseGhost() {
  for i:=0; i<4; i++ {
    if i32.eq(ghosts[i].status, GHOST_MODE_IN_HOUSE) {
      ghosts[i].index_x = f32.i32(GHOST_SPAWN_COLLUMN)
      ghosts[i].index_y = f32.i32(GHOST_SPAWN_LINE)
      ghosts[i].status = GHOST_MODE_CHASE
      //return;
      break
    }
  }
}

func isTimerOver(timer f64, limit f64) (is_over bool) {
  if gteq(f64.sub(glfw.GetTime(), timer), limit) {
    is_over = true
  }
}


// Collision manager functions

func checkPlayerGhostCollision(ghost Ghost) () {
  if bool.and(i32.eq(player.index_x, ghost.index_x), i32.eq(player.index_y, ghost.index_y)) {
    if i32.eq(ghost.status, GHOST_MODE_FRIGHTENED) {
      ghosts[ghost.gtype].index_x = 14
      ghosts[ghost.gtype].index_y = 13
      ghosts[ghost.gtype].status = GHOST_MODE_IN_HOUSE
    }

    if bool.or(i32.eq(ghost.status, GHOST_MODE_CHASE), i32.eq(ghost.status, GHOST_MODE_SCATTER)) {
      PLAYER_LIVES = i32.sub(PLAYER_LIVES, 1)
      if i32.lteq(PLAYER_LIVES, 0) {
        GAME_OVER = true
        str.print("------ GAME OVER ------") // FIX ME add game over screen
      } else {
        player = newPlayer(PLAYER_SPAWN_LINE, PLAYER_SPAWN_COLLUMN, PLAYER_RADIUS)
      }
    }
  }
}



/***************************************
 * Initialization functions.
***************************************/

/* Function     : initGLFW
   Desctription : Initializes the game window and keyboard input manager.
*/
func initGLFW() () {
  glfw.Init()

  glfw.CreateWindow("window", WIDTH_WINDOW, HEIGHT_WINDOW, "PAC-MAN CX 0.0.3")
  glfw.MakeContextCurrent("window")

	gl.Init()
  gl.Enable(gl.BLEND)
  gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

  glfw.SetKeyCallback("window", "keyboardManager")
}

/* Function     : initOpenGL
   Output       : OpenGL program (program i32)
   Desctription : Initializes the OpenGL program.
*/
func initOpenGL() (program i32) {
	program = gl.CreateProgram()
  gl.LinkProgram(program)
}



/* Function     : keyboardManager
   Input        : active window (window str)
                : keyboard key (key i32)
                : scancode (scancode i32)
                : keyboard action (action i32)
                : modifiers (mods i32)
   Desctription : Manages the keyboard inputs.
*/
func keyboardManager(window str, key i32, scancode i32, action i32, mods i32) {
  if bool.and(i32.eq(key, RIGHT_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(RIGHT)
  }
  if bool.and(i32.eq(key, LEFT_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(LEFT)
  }
  if bool.and(i32.eq(key, DOWN_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(DOWN)
  }
  if bool.and(i32.eq(key, UP_ARROW_KEY), i32.eq(action, 1)) {
    movePlayer(UP)
  }
}
