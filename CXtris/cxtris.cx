package main

import "app"
import "inputs"
import "menu"



func initGame () {
	shape.Init()
	draw.Init()
	inputs.Init()
	inputs.BufferPointerSpots = true
	inputs.BufferNotchyDeltas = true
}


func update () {
	respondToButtonEvents()
	respondToKeyEvents()
	respondToPointerEvents()
	respondToNotchyMouseDeltas()
}


func respondToNotchyMouseDeltas () {
	var v app.Vec2I = inputs.GetNotchyMouseDelta ()
	
	if v.X != app.MAX_I32 {
		shape.MoveByOffset(v.X, v.Y)
	}
}


func respondToButtonEvents () {
	var button i32
	var action i32
	button, action = inputs.GetButtonEvent ()
		
	if action == 0 { // release 
	} else 
	if action == 1 { // press 
		if button == 0 { // LMB 
			if app.Mode <= app.MODE_MENU_OPTIONS { // in a menu 
				respondToMenuClicks()
			}
			
			shape.PlayerRotate(-1)
		} else
		if button == 1 { // RMB 
			shape.PlayerRotate(1)
		} else { // MMB or extra buttons (would be unwise to require more than 3 buttons) 
		}
	}
}


func respondToKeyEvents () {
	var key    i32
	var action i32
	key, action = inputs.GetKeyEvent ()

	// action 0, release 
	// action 1, press 
	// action 2, autorepeat event (generated by keys that are held longer than a second) 

	if action >= 1 { // (press or repeat) 
		//str.print("-------------------------------------PRESS (not a repeat)")

		inputs.MaybeOpenMenu(key)
		
		if key == inputs.GLFW_KEY_5 { 
			// close 
			str.print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ QUITTING GAME ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
			glfw.SetShouldClose(app.Name, true)
		} else
		if app.Mode == app.MODE_PLAYING {
			if inputs.EventLeft(key) {
				shape.MoveByOffset(-1, 0)
			} else
			if inputs.EventRight(key) {
				shape.MoveByOffset(1, 0)
			} else
			if inputs.EventUp(key) {
				// NO NEED TO MOVE UP 
			} else
			if inputs.EventDown(key) {
				shape.MoveByOffset(0, -1)
			} else
			if inputs.EventRotateLeft(key) {
				shape.PlayerRotate(-1)
			} else
			if inputs.EventRotateRight(key) {
				shape.PlayerRotate(1)			
			}
		}
	}
}


func respondToPointerEvents () {
	var v app.Vec2 = inputs.GetPointerEvent ()
		
	// allow dragging a slider handle 
	if inputs.HoldingLeftButton && 
		v.X != app.TOO_BIG_F32 &&
		app.Mode <= app.MODE_MENU_OPTIONS {
			
		respondToMenuDrags()
	}
}


func respondToMenuDrags () {
	var s str
	var i i32
	s, i = menu.GetHoveredItem(app.Mode)

	/*
	if s == menu.ItemText {
		menu.Setting = menu.SetSliderValue(i, f64.f32(MousePointerX64))
	} else
	*/
	if s == menu.DebrisHeightText {
		menu.DebrisHeight = menu.SetSliderValue(i, f64.f32(inputs.MousePointerX64))
		shape.StartNewGameSession()
	} else
	if s == menu.SpeedText {
		time.DropSpeed =    menu.SetSliderValue(i, f64.f32(inputs.MousePointerX64))
		time.CalcDropTime()
	}
}


func respondToMenuClicks () {
	var s str
	var i i32
	s, i = menu.GetHoveredItem(app.Mode)

	if s == menu.Play {
		inputs.SetMousePointer(false)
		shape.PlayerScore    =  0
		shape.PlayerScoreTxt = "0"
		shape.StartNewGameSession
		app.Mode = app.MODE_PLAYING
	} else
	if s == menu.Options {
		app.Mode = app.MODE_MENU_OPTIONS
	} else
	if s == menu.Quit {
		glfw.SetShouldClose(app.Name, true)
	} else
	if s == menu.ShowNextShapeText + "YES" {
		    menu.ShowNextShape = false
		menu.Items[app.Mode][i].Text = menu.ShowNextShapeText + "NO"
	} else
	if s == menu.ShowNextShapeText + "NO" {
		    menu.ShowNextShape = true
		menu.Items[app.Mode][i].Text = menu.ShowNextShapeText + "YES"
	}
}
