package ccInput        // "input" must be reserved?  got errors until I renamed this

import "glfw"
//import "entity"



var currMouseX f64
var currMouseY f64

// key codes 
// 		developer quick exit 
var GLFW_KEY_5 i32
//		shooting
/*
var GLFW_KEY_SPACE     i32 = 32
//		escape to menu
var GLFW_KEY_ESCAPE    i32 = 256
var GLFW_KEY_ENTER     i32 = 257
var GLFW_KEY_TAB       i32 = 258
var GLFW_KEY_BACKSPACE i32 = 259
// 		directional keys 
var	GLFW_KEY_A         i32 = 65
var	GLFW_KEY_D         i32 = 68
var	GLFW_KEY_W         i32 = 87
*/
var	GLFW_KEY_S i32

// cached values 
// 		move direction 
var moveLeft bool
var moveRight bool
var moveUp bool
var moveDown bool
//		buttons 
var prevMouseX f64
var prevMouseY f64



func Init() () {
	prevMouseX = 0.0D - 7.0D
	prevMouseY = 0.0D - 7.0D
	GLFW_KEY_S = 83

/*
	glfw.SetKeyCallback("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback("window", "onCursorPosEvent")
*/
}


func Update() () {
	// motion input status 
	/*
	moveLeft  = keyIsDown(GLFW_KEY_A)
	moveRight = keyIsDown(GLFW_KEY_D)
	moveUp    = keyIsDown(GLFW_KEY_W)
	*/
	//moveDown  = keyIsDown(GLFW_KEY_S)
	//str.print("call SetPlayerVelocity() causing prob")
}


// mouse buttons 
var LeftMouseButtonDown bool // cache status 
func onMouseButtonEvent(window str, button i32, action i32, mods i32) () {
	if action == /* Release */ 0 {
		if  button == glfw.MouseButtonLeft {
			LeftMouseButtonDown = false
		}
	} else {
		// do nothing if action == Repeat 

		if action == /* Press */ 1 {
			LeftMouseButtonDown = true
			//maybeSetAnalogSensitivity(currMouseX, currMouseY)

			/*
			if game.Mode >= game.MODE_Playing {
				entity.Shoot(0)
			} else { // must be in menu 
				btn := game.GetTextOnButtonThatPointerIsOn()
				str.print(btn)

				if btn == "Play" {
					game.SetMode(game.MODE_Playing)
					glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
				} else { // FIXME when CX gets switches 
					if btn == "Options" {
						game.SetMode(game.MODE_OptionsMenu)
					} 
					
					if btn == "Quit" {
						glfw.SetShouldClose("window", glfw.True)
					}
					
					if btn == game.MenuItemBack {
						game.SetMode(game.MODE_MainMenu)
					}
				}
			}
			*/
		}
	}
}



// mouse position

func onCursorPosEvent(window str, x f64, y f64) () {
	currMouseX = x
	currMouseY = y

	// if not the 1st time (when delta would have no meaning) 
	if prevMouseX != 0.0D &&
		prevMouseY != 0.0D {
		
		/*
		if game.Mode >= game.MODE_Playing {
			deltaX := x - prevMouseX
			deltaY := y - prevMouseY
			// invert from pixel to world aligned space 
			// (value increases going up the screen)
			deltaY = 0.0D - deltaY 

			//a := str.concat("cursor event delta ---- x ", f64.str(deltaX))
			//b := str.concat(", y "                      , f64.str(deltaY))
			//str.print(str.concat(a, b))

			game.SetSnakeAimAndSize(
				f64.f32(deltaX),
				f64.f32(deltaY))
		} else { // not playing 
			maybeSetAnalogSensitivity(x, y)
		}
		*/
	}
	
	prevMouseX = x
	prevMouseY = y
}





func maybeGoToMainMenu(key i32) () {
	str.print("maybe")
	//i32.print(key)

	if key == 256 /* GLFW_KEY_ESCAPE */ || 
		key == 257 /* GLFW_KEY_ENTER */ ||
		key == 258 /* GLFW_KEY_TAB */ || 
		key == 259 /* GLFW_KEY_BACKSPACE */ {

		str.print("DEF go to main menu")
		//game.SetMode(game.MODE_MainMenu)
		//str.print("glfw.SetInputMode("window", glfw.Cursor, glfw.CursorNormal)
	}
}


func maybeSetAnalogSensitivity(x f64, y f64) () {
	str.print("maybeSetAnalogSensitivity()")

	/*
	game.SetIdOfButtonThatPointerIsOn(x, y)

	// respond to mouse buttons 
	if game.Mode == game.MODE_OptionsMenu && LeftMouseButtonDown {
		t := game.GetTextOnButtonThatPointerIsOn()
		fx := getFractionOfSliderMaxValue(x)

		if t == game.AnalogControlsSensitivityAimText {
			str.print("sens x:")
			game.SetAnalogControlsSensitivityAim(fx)
			f32.print(fx)
		}

		if t == game.AnalogControlsSensitivitySpeedText {
			str.print("sens y:")
			game.SetAnalogControlsSensitivitySpeed(fx)
			f32.print(fx)
		}
	}
	*/
}


func keyIsDown(key i32) (out bool) {
	// GetKey() never gives a "repeat" action (only gives 0 & 1)
	out = false

	if i32.eq(glfw.GetKey("window", key), 1) {
		out = true
	}
}


func SetPlayerVelocity() () {
	str.print("SetPlayerVelocity()")

	/*
	// horizontal 

	if moveLeft {
		entity.ForceNegativeVelocityAndBloomIt(0, true)
	} else {
		if moveRight {
			entity.ForcePositiveVelocityAndBloomIt(0, true)
		} else {
			entity.SlowDownInAxis(0, true)
		}
	}
	


	// vertical 

	if moveDown {
		entity.ForceNegativeVelocityAndBloomIt(0, false)
	} else {
		if moveUp {
			entity.ForcePositiveVelocityAndBloomIt(0, false)
		} else {
			entity.SlowDownInAxis(0, false)
		}
	}
	*/
}


func getFractionOfSliderMaxValue(x f64) (out f32) {
	/*
	fx := f64.f32(x) / i32.f32(game.ScreenNumPixelsWide)
	fx *= (game.WindowExtentX * 2.0)
	str.print("fraction")
	// from left edge  
	offset := game.WindowExtentX - game.LongestCurrMExtent
	offset += game.SliderHandleExtentX
	fx -= offset
	fx /= (game.LongestCurrMExtent * 2.0 - 
			game.SliderHandleExtentX * 2.0)

	if fx > 1.0 {
		fx = 1.0
	}

	if fx < 0.0 {
		fx = 0.0
	}

	f32.print(fx)

	return fx
	*/
}