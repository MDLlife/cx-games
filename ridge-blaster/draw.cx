package draw

import "gl"

import "app"
import "collision"
import "entity"
import "environs"



func Setup () () {
	str.print("draw.Setup()")
}


func All () () {
	//str.print("draw.Update()")


	gl.Begin(gl.QUADS) //POLYGON
	
	Terrain()
	//ColorPickerWheel()
	Entities()

	gl.End()


	gl.Begin(gl.POLYGON)
	simpleVertexSequence(0.0)
	gl.End()


	gl.Begin(gl.LINE_LOOP)
	simpleVertexSequence(0.5)
	gl.End()


	gl.Begin(gl.LINES)
	gridLines()
	gl.End()


	Circle(entity.ball)
}


func gridLines () () {
	var l f32
	l = f64.f32(collision.ScreenEdgeL)
	var r f32
	r = f64.f32(collision.ScreenEdgeR)
	numLines := 30
	var unitSpan f32
	unitSpan = f32.mul(r, 2.0)
	unitSpan = f32.div(unitSpan, i32.f32(numLines))
	printf("unitSpan: %v\n", unitSpan)
	z := 0.2

	// vertical 
	var fx f32
	fx = l
	for x := 0; x < numLines; x++ {
		gl.Vertex3f(fx, l, z)
		gl.Vertex3f(fx, r, z)
		
		printf("fx before inc: %v\n", fx)
		fx = f32.add(fx, unitSpan)
	}
	
	// horizontal 
	var fy f32
	fy = l
	for y := 0; y < numLines; y++ {			
		gl.Vertex3f(l, fy, z)
		gl.Vertex3f(r, fy, z)
		
		fy = f32.add(fy, unitSpan)
	}
}


func Circle (ball Entity) () {
	var x f32
	var y f32

	gl.Begin(gl.POLYGON)
	gl.Color3f(1.0, 1.0, 1.0)
	
	var i f32
	for i = 0.0; f32.lt(i, 20.0); i = f32.add(i, 1.0) {
		x = f32.add(ball.Pos.X, f32.mul(ball.radius, f32.cos(f32.div(f32.mul(i, app.TAU), 20.0))))
		y = f32.add(ball.Pos.Y, f32.mul(ball.radius, f32.sin(f32.div(f32.mul(i, app.TAU), 20.0))))

		gl.Vertex2f(x, y)
	}

	gl.End()
}


func Terrain () () {
	var green f32
	green = 0.2

	var num i32
	num = len(environs.Terrain) - 1

	var x f32
	x = f64.f32(collision.ScreenEdgeL)

	var bott f32
	bott = 0.0 - 1.0

	var span f32
	span = f32.div(f64.f32(collision.ScreenEdgeR) * 2.0, i32.f32(num))

	for i := 0; i < num; i++ {
		gl.Color3f(0.6, green, 1.0)

		z := 0.0 - environs.Terrain[i].Floo
		y :=  bott
		gl.Vertex3f(x, y, z)

		y = environs.Terrain[i].Floo
		gl.Vertex3f(x, y, z)

		x = f32.add(x, span)

		y =  environs.Terrain[i+1].Floo
		gl.Vertex3f(x, y, z)

		y = bott
		gl.Vertex3f(x, y, z)
		
		green = f32.add(green, 0.22)
	}
}


func Entities () () {
	c := 1.0
	gl.Color3f(c, c, c)

	for i := 0; i < len(entity.Ents); i++ {
		var e Entity
		e = entity.Ents[i]

		var f f32
		f = 0.009

		var lX f32
		lX = f32.sub(e.Pos.X, f)

		var rX f32
		rX = f32.add(e.Pos.X, f)

		var bY f32
		bY = f32.sub(e.Pos.Y, f)

		var tY f32
		tY = f32.add(e.Pos.Y, f)
		
		gl.Vertex2f(lX, bY)
		gl.Vertex2f(lX, tY)
		gl.Vertex2f(rX, tY)
		gl.Vertex2f(rX, bY)
	}
}


func simpleVertexSequence (colorChanIntensity f32) () {
	gl.Color3f(colorChanIntensity, colorChanIntensity, colorChanIntensity)

	for i := 0; i < len(entity.Ents); i++ {
		var e Entity
		e = entity.Ents[i]

		gl.Vertex2f(e.Pos.X, e.Pos.Y)
	}
}


func ColorPickerWheel () () {
	var NUM_ANGS i32
	NUM_ANGS = 1536 // 3 x 512, 512 needed to show all possible hues between 2 colors 
	// (256 settings per channel, but we alternate between inc/dec 1 chan at a time)

	var ANG_I /* angle increment */ f32
	ANG_I = f32.div(app.TAU, i32.f32(NUM_ANGS))

	var CI /* color increment */ f32
	CI = f32.div(1.0, i32.f32(256))

	var ang f32
	var increase bool
	increase = true

	var red f32
	var green f32
	var blue f32
	red = 1.0

	for i := 0; i < NUM_ANGS; i++ {
		gl.Color3f(red, green, blue)

		gl.Vertex2f(0.0, 0.0)
		gl.Vertex2f(0.0, 0.0)
		gl.Vertex2f(f32.sin(ang), f32.cos(ang))

		ang = f32.add(ang, ANG_I)

		gl.Vertex2f(f32.sin(ang), f32.cos(ang))

		if i >= 1024 {
			if increase {
				red = f32.add(red, CI)
			} else {
				blue = f32.sub(blue, CI)
			}
		} else
		if i >= 512 {
			if increase {
				blue = f32.add(blue, CI)
			} else {
				green = f32.sub(green, CI)
			}
		} else {
			if increase {
				green = f32.add(green, CI)
			} else {
				red = f32.sub(red, CI)
			}
		}

		increase = bool.not(increase)
	}
}
