package ccInput

import "glfw"

import "app"
import "collision"
import "entity"
import "mesh"



var MousePointer       Vec2
var SnapToGrid         bool
var draggingVertexNode bool
var draggedVertexId    i32

// keys 
var	GLFW_KEY_W i32
var	GLFW_KEY_A i32
var	GLFW_KEY_S i32
var	GLFW_KEY_D i32

var GLFW_KEY_SPACE  i32 = 32
var GLFW_KEY_N      i32
var GLFW_KEY_Y      i32
var GLFW_KEY_F2     i32
var GLFW_KEY_F3     i32
var GLFW_KEY_ESCAPE i32 = 256



func Setup () () {
	str.print("input/ccInput.Setup()")

	// keys 
	GLFW_KEY_W = 87
	GLFW_KEY_A = 65
	GLFW_KEY_S = 83
	GLFW_KEY_D = 68	
	
	GLFW_KEY_N = 78
	GLFW_KEY_Y = 89
	GLFW_KEY_F2 = 291
	GLFW_KEY_F3 = 292
	
	setupEditorToolbar()

	// callbacks 
	glfw.SetKeyCallback("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback("window", "onCursorPosEvent")
}


func InpUpdate () () {
	//str.print("input/ccInput.InpUpdate()")

	// motion input status 
	//moveLeft  = keyIsDown(GLFW_KEY_A)
	//moveRight = keyIsDown(GLFW_KEY_D)
	//moveUp    = keyIsDown(GLFW_KEY_W)
	//moveDown  = keyIsDown(GLFW_KEY_S)
	//str.print("call SetPlayerVelocity() causing prob")
}


// mouse buttons 
func onMouseButtonEvent (window str, button i32, action i32, mods i32) () {
	if /* release */ action == 0 {
		if button == 0 {
			draggingVertexNode = false
		}
	} else if /* press */ action == 1 {
		//printf("onMouseButtonEvent() - %f, %f \n", MousePointer.X, MousePointer.Y)

		if button == 0 {
			fireOrActivate()
		} else
		if button == 1 && 
			app.Mode == app.MODE_EDITOR &&
			app.EditMode == app.EDIT_VERTICES {
			
			str.print("RMB press && EDIT_VERTICES")
			var touchedVert bool
			var i i32
			touchedVert, i = getTouchedVertexNode(MousePointer)
			
			if touchedVert {			
				mesh.RemoveVertexNode(i)
			}
		}
	}
}


// mouse position 
func onCursorPosEvent (window str, x f64, y f64) () {
	var mX f32
	mX = f32.div(f64.f32(x), i32.f32(app.ScreenSizeInPixels.X))
	mX = f32.mul(mX, f64.f32(collision.ScreenEdgeR) * 2.0)
	MousePointer.X = f32.add(f64.f32(collision.ScreenEdgeL), mX)

	var mY f32
	mY = f32.div(f64.f32(y), i32.f32(app.ScreenSizeInPixels.Y))
	mY = f32.mul(mY, 2.0)
	MousePointer.Y = f32.sub(1.0, mY)
	
	if draggingVertexNode {
		mesh.RawMeshes[0].Points[draggedVertexId].X = MousePointer.X
		mesh.RawMeshes[0].Points[draggedVertexId].Y = MousePointer.Y
	}
	
	//printf("onCursorPosEvent %f, %f \n", MousePointer.X, MousePointer.Y)
}


// keys 
func onKeyEvent (window str, key i32, scancode i32, action i32, mods i32) () {
	// action == 0, release 
	// action == 1, press 
	// action == 2, is an autorepeat event, generated by keys that are held longer than a second

	if action != 2 { // (not a repeat) 
		if action == 1 { // (press) 
			//str.print("-------------------------------------PRESS (not a repeat)")

			//if key == 50 { // GLFW_KEY_2 
			//} else
			//if key == 51 { // GLFW_KEY_3 
			//} else
			if key == GLFW_KEY_ESCAPE {
				app.Mode = app.MODE_EDITOR
			} else
			if key == 53 { // GLFW_KEY_5 
				// close 
				str.print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ QUITTING GAME ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
				glfw.SetShouldClose("window", true)
			} else
			if key == GLFW_KEY_SPACE {
				fireOrActivate()
			}

			//maybeToggleMousePointer(key)
		}
	}
}


var wantMousePointer bool
func maybeToggleMousePointer (key i32) () {
	i32.print(key)

	if key == 256 || // GLFW_KEY_ESCAPE 
		key == 257 || // GLFW_KEY_ENTER
		key == 258 || // GLFW_KEY_TAB 
		key == 259 { // GLFW_KEY_BACKSPACE 

		str.print("DEF go to main menu")
		wantMousePointer = !wantMousePointer

		if bool.eq(wantMousePointer, true) {
			str.print("wantMousePointer TRUE")
			glfw.SetInputMode("window", glfw.Cursor, glfw.CursorNormal)
		} else {
			str.print("wantMousePointer FALSE")
			glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
		}
	}
}


func fireOrActivate () () {
	//str.print("fireOrActivate ()")
	var t    i32
	var mode i32
	var pos  Vec2
	var vel  Vec2
	var ext  Vec2
	
	// handle modes 
	if app.Mode < app.MODE_GAME_OVER { // playing 
		t = entity.TYPE_BULLET
		pos = entity.Ents[0].Pos
		pos.X = f32.add(pos.X, entity.Ents[0].Extents.X)
		pos.X = f32.add(pos.X, entity.BulletExtents.X)
		pos.X = f32.add(pos.X, 0.03) // hero to bullet padding 
		vel = Vec2{ X: app.MAX_HERO_SPEED * 2.0, Y: 0.0 }
		mode = entity.MODE_MOVING_STRAIGHT
		ext = entity.BulletExtents
	
		var ent Entity
		ent = Entity{ 
			Type: t, 
			Pos: pos, 
			Vel: vel, 
			Mode: mode, 
			Extents: ext }
		
		entity.Add(ent)
	} else if app.Mode == app.MODE_EDITOR {
		var touchedMI bool // menu item 
		var i i32
		touchedMI, i = getTouchedMenuItem(MousePointer)
		
		if touchedMI {
			printf("pressed menu item %s \n", Menu[i].Name)
			
			if i < app.EDIT_MAX { // change EditMode
				app.EditMode = i

				if app.EditMode == app.EDIT_VERTICES {
					str.print("-> MODE EDIT_VERTICES")
				} else
				if app.EditMode == app.EDIT_TRIANGLES {
					str.print("-> MODE EDIT_TRIANGLES")
				} else
				if app.EditMode == app.EDIT_COLORS {
					str.print("-> MODE EDIT_COLORS")
				}
			} else { // perform one-time actions 
				if i == TOOLBAR_GEN_FUNC {
					mesh.GenerateMeshInitFunc("Char") //"Icon")
				} else
				if i == TOOLBAR_SNAP_TO_GRID {
					SnapToGrid = !SnapToGrid
					
					if SnapToGrid {
						str.print("SNAP_TO_GRID: ON")					
					} else {
						str.print("SNAP_TO_GRID: OFF")
					}
				} else
				if i == TOOLBAR_NEW_CANVAS {
					str.print("-> NEW_CANVAS")
					var m Mesh2D
					m = Mesh2D{ Name: "Editor workspace" }
					mesh.RawMeshes[0] = m
				} else
				if i == TOOLBAR_MAINMENU {
					str.print("-> MAINMENU")
					app.Mode = app.MODE_MENU
				}
			}
			
			/////
			/////
			return ///// don't want to use any vertex nodes 
			/////
			/////
		}
		
		var touchedVert bool
		touchedVert, i = getTouchedVertexNode(MousePointer)

		if app.EditMode == app.EDIT_TRIANGLES {
			// TODO enhancement: allow player to slide across 3 verts while holding LMB 
			
			if touchedVert {			
				printf("RawMeshes[0].Points' i: %d \n", i)

				if i32.gteq(mesh.PickedTrianglesNextId, 3) {
					mesh.PickedTrianglesNextId = 0
				}

				mesh.PickedTriangle[mesh.PickedTrianglesNextId] = i
				mesh.PickedTrianglesNextId = i32.add(mesh.PickedTrianglesNextId, 1)

				if i32.gteq(mesh.PickedTrianglesNextId, 3) {
					mesh.MakeNewEditorTriangle()
				}
			}
		} else if app.EditMode == app.EDIT_VERTICES {
			if touchedVert {
				draggingVertexNode = true
				draggedVertexId = i
			} else {
				var c Color3
				c = Color3{ 
					R: 0.5, 
					G: 0.5, 
					B: 0.5 }

				printf("Adding vertex node: %d \n", len(mesh.RawMeshes[0].Points))

				mesh.RawMeshes[0].Colors = append(
				mesh.RawMeshes[0].Colors, c)
				mesh.RawMeshes[0].Points = append(
				mesh.RawMeshes[0].Points, MousePointer)
			}
		}
	}
}


func getTouchedMenuItem (p Vec2) (touched bool, id i32) {
	touched = false
	
	for i := 0; i32.lt(i, len(Menu)); i++ {
		var v Vec2
		var e Vec2
		v = Menu[i].Pos
		e = Menu[i].Extents
		
		if p.X > (v.X - e.X) &&
			p.X < (v.X + e.X) &&
			p.Y > (v.Y - e.Y) &&
			p.Y < (v.Y + e.Y) {
			
			touched = true
			id = i			
			break
		}
	}
}


func getTouchedVertexNode (p Vec2) (touched bool, id i32) {
	touched = false
	
	for i := 0; i32.lt(i, len(mesh.RawMeshes[0].Points)); i++ {
		var v Vec2
		v = mesh.RawMeshes[0].Points[i]
		
		if p.X > (v.X - entity.NodeExtents.X) &&
			p.X < (v.X + entity.NodeExtents.X) &&
			p.Y > (v.Y - entity.NodeExtents.Y) &&
			p.Y < (v.Y + entity.NodeExtents.Y) {
			
			touched = true
			id = i			
			break
		}
	}
}
