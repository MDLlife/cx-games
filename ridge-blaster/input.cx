package ccInput

import "glfw"

import "app"
import "collision"
import "entity"



var MousePointer Vec2

// keys 
var	GLFW_KEY_W i32
var	GLFW_KEY_A i32
var	GLFW_KEY_S i32
var	GLFW_KEY_D i32

var GLFW_KEY_N i32
var GLFW_KEY_Y i32
var GLFW_KEY_F2 i32
var GLFW_KEY_F3 i32



func Setup () () {
	str.print("input/ccInput.Setup()")

	// keys 
	GLFW_KEY_W = 87
	GLFW_KEY_A = 65
	GLFW_KEY_S = 83
	GLFW_KEY_D = 68	
	
	GLFW_KEY_N = 78
	GLFW_KEY_Y = 89
	GLFW_KEY_F2 = 291
	GLFW_KEY_F3 = 292

	// callbacks 
	glfw.SetKeyCallback("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback("window", "onCursorPosEvent")
}


func InpUpdate () () {
	//str.print("input/ccInput.InpUpdate()")

	// motion input status 
	//moveLeft  = keyIsDown(GLFW_KEY_A)
	//moveRight = keyIsDown(GLFW_KEY_D)
	//moveUp    = keyIsDown(GLFW_KEY_W)
	//moveDown  = keyIsDown(GLFW_KEY_S)
	//str.print("call SetPlayerVelocity() causing prob")
}


// mouse buttons 
func onMouseButtonEvent (window str, button i32, action i32, mods i32) () {
	//printf("onMouseButtonEvent() - %f, %f \n", MousePointer.X, MousePointer.Y)

	if /* press */ action == 1 {
		var t    i32
		var mode i32
		var pos  Vec2
		var vel  Vec2
		var ext  Vec2
		
		if app.Mode < app.MODE_GAME_OVER {
			t = entity.TYPE_BULLET
			pos = entity.Ents[0].Pos
			pos.X = f32.add(pos.X, entity.Ents[0].Extents.X)
			pos.X = f32.add(pos.X, entity.BulletExtents.X)
			vel = Vec2{ X: 0.01, Y: 0.0 }
			mode = entity.MODE_MOVING_STRAIGHT
			ext = entity.BulletExtents
		} else {
			t = entity.TYPE_EDITOR_NODE
			pos = MousePointer
			vel = Vec2{ X: 0.0, Y: 0.0 }
			mode = entity.MODE_STATIONARY
			ext = entity.NodeExtents
		}
		
		var ent Entity
		ent = Entity{ 
			Type: t, 
			Pos: pos, 
			Vel: vel, 
			Mode: mode, 
			Extents: ext }
			
		entity.Add(ent)
	}
}


// mouse position 
func onCursorPosEvent (window str, x f64, y f64) () {
	var mX f32
	mX = f32.div(f64.f32(x), i32.f32(app.ScreenSizeInPixels.X))
	mX = f32.mul(mX, f64.f32(collision.ScreenEdgeR) * 2.0)
	MousePointer.X = f32.add(f64.f32(collision.ScreenEdgeL), mX)

	var mY f32
	mY = f32.div(f64.f32(y), i32.f32(app.ScreenSizeInPixels.Y))
	mY = f32.mul(mY, 2.0)
	MousePointer.Y = f32.sub(1.0, mY)
	
	//printf("onCursorPosEvent %f, %f \n", MousePointer.X, MousePointer.Y)
}


// keys 
func onKeyEvent (window str, key i32, scancode i32, action i32, mods i32) () {
	// action == 0, release 
	// action == 1, press 
	// action == 2, is an autorepeat event, generated by keys that are held longer than a second

	if action != 2 { // (not a repeat) 
		if action == 1 { // (press) 
			//str.print("-------------------------------------PRESS (not a repeat)")

			// close 
			if key == 53 { // GLFW_KEY_5 
				str.print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ QUITTING GAME ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
				glfw.SetShouldClose("window", true)
			}

			//maybeToggleMousePointer(key)
		}
	}
}


var wantMousePointer bool
func maybeToggleMousePointer (key i32) () {
	i32.print(key)

	if key == 256 || // GLFW_KEY_ESCAPE 
		key == 257 || // GLFW_KEY_ENTER
		key == 258 || // GLFW_KEY_TAB 
		key == 259 { // GLFW_KEY_BACKSPACE 

		str.print("DEF go to main menu")
		wantMousePointer = !wantMousePointer

		if bool.eq(wantMousePointer, true) {
			str.print("wantMousePointer TRUE")
			glfw.SetInputMode("window", glfw.Cursor, glfw.CursorNormal)
		} else {
			str.print("wantMousePointer FALSE")
			glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
		}
	}
}
