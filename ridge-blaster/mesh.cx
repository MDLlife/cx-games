package mesh

import "glfw"

import "app"



type Mesh2D struct {
	Name str
	Colors []Color3 // to keep it simple, we'll sync this with Points (rather than indices to a palette) 
	Points []Vec2
	TriangleIndices []i32
}

var Meshes []Mesh2D
var EditorMeshes []Mesh2D
var PickedTrianglesNextId i32
var PickedTriangle []i32



func Setup2 () () { // FIXME: rename when we can call _func_name_ within _same_func_name_ 
	str.print("mesh.Setup2()")
	
	// editor 
	var m Mesh2D
	m = Mesh2D{ Name: "Editor Mesh" }
	printf("generating a %s mesh with id: %d\n", m.Name, len(EditorMeshes))
	EditorMeshes = append(EditorMeshes, m)
	// 		triangle pick/selection 
	// 		(these values only used if PickedTrianglesNextId >= 3) 
	PickedTriangle = append(PickedTriangle, 0)
	PickedTriangle = append(PickedTriangle, 1)
	PickedTriangle = append(PickedTriangle, 2)
	// 		prelim toolbar menu 
	var y f32
	y = 1.0

	var h f32
	h = 0.1

	MakeNewMenuItemRect(y, -0.8, y - h, -1.0)
	y = f32.sub(y, f32.mul(h, 1.2))
	MakeNewMenuItemRect(y, -0.8, y - h, -1.0)
	y = f32.sub(y, f32.mul(h, 1.2))
	MakeNewMenuItemRect(y, -0.8, y - h, -1.0)
}


func Draw (/*tDelta f32*/) () {
	//str.print("mesh.Draw()")
}


func MakeNewMenuItemRect (top f32, right f32, bottom f32, left f32) () {
	var m Mesh2D
	m = Mesh2D{ Name: "Menu Item Rect" }
	
	
	// colors 
	var col Color3
	col = Color3{ R: 1.0, G: 0.2, B: 0.2 }

	var colSpan f32
	colSpan = 0.2	

	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)

		
	// positions 
	var v Vec2
	v = Vec2{ X: 0.0, Y: 0.0 }
	
	// start at... 
	v.X = left
	v.Y = top
	// ...then go clockwise 
	m.Points = append(m.Points, v)
	v.X = right
	v.Y = top
	m.Points = append(m.Points, v)
	v.X = right
	v.Y = bottom
	m.Points = append(m.Points, v)
	v.X = left
	v.Y = bottom
	m.Points = append(m.Points, v)

		
	// triangles 
	m.TriangleIndices = append(m.TriangleIndices, 0)
	m.TriangleIndices = append(m.TriangleIndices, 1)
	m.TriangleIndices = append(m.TriangleIndices, 2)

	m.TriangleIndices = append(m.TriangleIndices, 2)
	m.TriangleIndices = append(m.TriangleIndices, 3)
	m.TriangleIndices = append(m.TriangleIndices, 0)
	
	printf("generating a %s mesh with id: %d\n", m.Name, len(Meshes))
	EditorMeshes = append(EditorMeshes, m)
}


func MakeNewTriangle /* NON-editor */ (a Vec2, b Vec2, c Vec2) () {
	////////////////// UNTESTED \\\\\\\\\\\\\\\\\\\\\
	str.print("mesh.MakeNewTriangle()   (NON-editor)")
	
	var m Mesh2D
	m = Mesh2D{ Name: "NON-editor triangle" }
	
	var col Color3
	col = Color3{ R: 1.0, G: 0.5, B: 0.9 }
	
	m.Colors = append(m.Colors, col)
	col.B = 0.6
	m.Colors = append(m.Colors, col)
	col.B = 0.2
	m.Colors = append(m.Colors, col)
	
	m.Points = append(m.Points, a)
	m.Points = append(m.Points, b)
	m.Points = append(m.Points, c)
	
	var tii /* tri indices index */ i32
	tii = len(Meshes[0].TriangleIndices)
	
	Meshes[0].TriangleIndices = append(Meshes[0].TriangleIndices, tii)
	tii = i32.add(tii, 1)
	Meshes[0].TriangleIndices = append(Meshes[0].TriangleIndices, tii)
	tii = i32.add(tii, 1)
	Meshes[0].TriangleIndices = append(Meshes[0].TriangleIndices, tii)
	
	printf("generating a %s mesh with id: %d\n", m.Name, len(Meshes))
	Meshes = append(Meshes, m)
}


func MakeNewEditorTriangle () () { // just tri indices to existing global (ATM) EditorMesh 
	str.print("mesh.MakeNewEditorTriangle()")
	
	
	// feedback BEFORE 
	printf("PickedTriangle[0]: %d \n", PickedTriangle[0])
	printf("PickedTriangle[1]: %d \n", PickedTriangle[1])
	printf("PickedTriangle[2]: %d \n", PickedTriangle[2])
	
	var numIds i32
	numIds = len(EditorMeshes[0].TriangleIndices)
	printf("numIds BEFORE: %d \n", numIds)
	
	var numErrs i32 // erroneous leftover indices (indicating not a multiple of 3) 
	var numTris i32
	numTris = i32.div(numIds, 3)
	numErrs = i32.mod(numIds, 3)
	printf("numTris BEFORE: %d \n", numTris)
	
	
	// MEAT of func 
	EditorMeshes[0].TriangleIndices = append(EditorMeshes[0].TriangleIndices, PickedTriangle[0])
	EditorMeshes[0].TriangleIndices = append(EditorMeshes[0].TriangleIndices, PickedTriangle[1])
	EditorMeshes[0].TriangleIndices = append(EditorMeshes[0].TriangleIndices, PickedTriangle[2])


	// feedback AFTER 
	numIds  = len(EditorMeshes[0].TriangleIndices)
	numTris = i32.div(numIds, 3)
	numErrs = i32.mod(numIds, 3)
	printf("numIds AFTER: %d \n", numIds)
	printf("numTris AFTER: %d \n", numTris)
	
	if i32.uneq(numErrs, 0) {
		printf("********* ERROR! numErrs: %d \n", numErrs)
		printf("********* ERROR! numErrs: %d \n", numErrs)
		printf("********* ERROR! numErrs: %d \n", numErrs)
	}

	printf("EditorMeshes[0].Points len: %d \n", len(EditorMeshes[0].Points))
}


func GenerateFromUsersEdit () () {
	str.print("mesh.GenerateFromUsersEdit ()")
	var m Mesh2D
	m = Mesh2D{ Name: "UserGenMesh" }
	
	for i := 0; i32.lt(i, len(EditorMeshes[0].Points)); i++ {
		m.Colors = append(m.Colors, EditorMeshes[0].Colors[i])
		m.Points = append(m.Points, EditorMeshes[0].Points[i])
	}

	for j := 0; i32.lt(j, len(EditorMeshes[0].Points)); j++ {
		m.TriangleIndices = append(m.TriangleIndices, EditorMeshes[0].TriangleIndices[j])
	}
		
	printf("generating a %s mesh with id: %d\n", m.Name, len(Meshes))
	Meshes = append(Meshes, m)
}


func RemoveVertexNode () () {
	if /* NOT editing */ 
		i32.lt(app.Mode, app.MODE_EDIT_VERTICES) ||
		i32.gt(app.Mode, app.MODE_EDIT_MAX) {
		
		return
	}
	
	printf("mesh.RemoveVertexNode() \n")

	var id i32
	id = 1
	
	var m Mesh2D
	m = Mesh2D{ Name: EditorMeshes[0].Name }

	for i := 0; i32.lt(i, len(EditorMeshes[0].Points)); i++ {
		if i32.uneq(i, id) {
			m.Colors = append(m.Colors, EditorMeshes[0].Colors[i])
			m.Points = append(m.Points, EditorMeshes[0].Points[i])
		}
	}

	for j := 2; i32.lt(j, len(EditorMeshes[0].TriangleIndices)); j = i32.add(j, 3) {
		var j0 i32
		var j1 i32
		var j2 i32
		j0 = i32.sub(j, 2)
		j1 = i32.sub(j, 1)
		j2 = j
		
		if i32.uneq(j0, id) &&
			i32.uneq(j1, id) &&
			i32.uneq(j2, id) {
			
			m.TriangleIndices = append(m.TriangleIndices, getMaybeAdjustedId(id, j0))
			m.TriangleIndices = append(m.TriangleIndices, getMaybeAdjustedId(id, j1))
			m.TriangleIndices = append(m.TriangleIndices, getMaybeAdjustedId(id, j2))
		}
	}

	EditorMeshes[0] = m
}


func getMaybeAdjustedId (removeId i32, triId i32) (outId i32) {
	outId = EditorMeshes[0].TriangleIndices[triId]

	// decrease vertex id by 1, if after removed index 
	if i32.gt(outId, removeId) {
		outId = i32.sub(outId, 1)
	}
}
