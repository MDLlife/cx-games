package game


import "gl"
import "glfw"

import "app"
import "ccInput"
import "collision"
import "draw"
import "entity"
import "environs"



// 		timing 
var prevTime f32 // previous 
var currTime f32 // current 
var timeDelta f32

// graphics 
var WIDTH i32 = 1280
var HEIGHT i32 = 720
var bufferWidth i32
var bufferHeight i32
var ratio f32
var program i32



func Init () () {
	str.print("game.Init()")

	// graphics 
	glfw.Init()
	glfw.CreateWindow("window", WIDTH, HEIGHT, app.NAME)
	glfw.MakeContextCurrent("window")
	gl.Init()
	program = gl.CreateProgram()
	gl.LinkProgram(program)

	app.Setup()
	ccInput.Setup()
	collision.Setup()
	environs.Setup()
	entity.Setup()
	draw.Setup()
}


func Update () () {
	updateTiming()
	ccInput.InpUpdate()
	entity.EntUpdate(timeDelta)


	// graphics 
	bufferWidth, bufferHeight = glfw.GetFramebufferSize("window")
	ratio = f32.div(i32.f32(bufferWidth), i32.f32(bufferHeight))
	gl.Clear(gl.COLOR_BUFFER_BIT)
	gl.UseProgram(program)
	gl.MatrixMode(gl.PROJECTION)
	gl.LoadIdentity()
	gl.Ortho(collision.lEdge, collision.rEdge, -1.0D, 1.0D, 1.0D, -1.0D)
	gl.Viewport(0, 0, bufferWidth, bufferHeight)
	gl.MatrixMode(gl.MODELVIEW)


	collision.ColUpdate(ratio)
	draw.Polygons()

	glfw.PollEvents()
	glfw.SwapBuffers("window")
}



func ShouldProceed () (out bool) {
	if glfw.ShouldClose("window") {
		out = false
	} else {
		out = true
	}
}


func updateTiming () () {
	// prevent 1st delta from being large, which would make moving objects teleport unpredictably 
	if prevTime == 0.0 {
		prevTime = f64.f32(glfw.GetTime())
	}

	currTime = f64.f32(glfw.GetTime())
	timeDelta = currTime - prevTime
	prevTime = currTime
}
