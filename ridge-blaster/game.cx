package game


import "gl"
import "glfw"

import "app"
import "ccInput"
import "collision"
import "draw"
import "entity"
import "environs"



// timing 
var prevTime  f32 // previous 
var currTime  f32 // current 
var timeDelta f32

// graphics 
var ratio f32
var program i32



func Init () () {
	str.print("game.Init()")

	// graphics 
	glfw.Init()
	glfw.CreateWindow("window", app.WIDTH, app.HEIGHT, app.NAME)
	glfw.MakeContextCurrent("window")
	gl.Init()
	program = gl.CreateProgram()
	gl.LinkProgram(program)

	app.Setup()
	ccInput.Setup()
	collision.Setup()
	environs.Setup()
	entity.Setup()
	draw.Setup()
}


func Update () () {
	updateTiming()
	ccInput.Update()
	entity.Update(timeDelta, currTime)


	// graphics 
	app.ScreenSizeInPixels.X, app.ScreenSizeInPixels.Y = glfw.GetFramebufferSize("window")
	ratio = f32.div(i32.f32(app.ScreenSizeInPixels.X), i32.f32(app.ScreenSizeInPixels.Y))
	gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
	gl.UseProgram(program)
	gl.MatrixMode(gl.PROJECTION)
	gl.LoadIdentity()
	
	gl.Ortho(collision.ScreenEdgeL, collision.ScreenEdgeR, -1.0D, 1.0D, 1.0D, -1.0D)
		//gl.Rotatef(entity.CamRot.X, 1.0, 0.0, 0.0)
		//gl.Rotatef(entity.CamRot.Y, 0.0, 1.0, 0.0)
		//gl.Translatef(
			//entity.Ents[0].Pos.X, 
			//entity.Ents[0].Pos.Y, 
			//0.0)
		//gl.Translatef(
			//entity.CamPos.X,
			//entity.CamPos.Y,
			//entity.CamPos.Z)
		//printf("CamPos.X: %s \n", f32.str(entity.CamPos.X))
		
	gl.Viewport(0, 0, app.ScreenSizeInPixels.X, app.ScreenSizeInPixels.Y)
	gl.MatrixMode(gl.MODELVIEW)

	collision.Update(ratio)
	draw.All(currTime, timeDelta)

	glfw.PollEvents()
	glfw.SwapBuffers("window")
}



func ShouldProceed () (out bool) {
	if glfw.ShouldClose("window") {
		out = false
	} else {
		out = true
	}
}


func updateTiming () () {
	// prevent 1st delta from being large, which would make moving objects teleport unpredictably 
	if prevTime == 0.0 {
		prevTime = f64.f32(glfw.GetTime())
	}

	currTime = f64.f32(glfw.GetTime())
	timeDelta = currTime - prevTime
	prevTime = currTime
}
