/*

In our imagined world for this game, the universe is filled with solid
rock everywhere.

We have a limited grid of possibilities, where we will carve out air space
in MOST of those cells.  Some will remain
solid rock, for a bit of variety in overall map shape.

I THINK OF THE Y DIMENSION INCREASING UPWARDS
	SO KEEP THIS IN MIND WITH geom.DIR_...ECTIONS AND THE "Cells" GRID INDEXING 
	
This is how it is by default in OpenGL space, Unity and many modern 3D
apps, so I think it's important to generally keep synchronized with this.

*/

package map

import "app"
import "draw"
import "geom"



var NumCellsAcross i32 = 4 // in both dimensions 
var CellSpan f32 = 2.0 / i32.f32(NumCellsAcross)
var Cells [4][4]Cell   // FIXME: use constants when we can 
var Carvs []CarvedRoom // used/carved-out locations of the Cells grid 

type Cell struct {
	Exits     []i32
}

type CarvedRoom struct {
	// insets (from room bounds) 
	/*Top    f32
	Right  f32
	Bottom f32
	Left   f32*/
	
	Pos       app.Vec2i
	Exits     []i32
}



func Init () {
	//showActiveStatii()
	setupPossibleExits()
	//showActiveStatii()
	carveOutConnectedCells()
}


func DrawQuads () {
	var x f32
	var y f32

	draw.QuadsBegin()
		var n i32 = GetNumCarvs()
		//printf("murrr: %d \n", n)
		for i := 0; i < n; i++ {
			var p app.Vec2i = GetGridPos(i)
			var mulX f32 = f32.mul(i32.f32(p.X), CellSpan)
			var mulY f32 = f32.mul(i32.f32(p.Y), CellSpan)
			
			var b f32 = f32.add(-1.0, mulY)
			var l f32 = f32.add(-1.0, mulX)
			var t f32 = b + CellSpan
			var r f32 = l + CellSpan
			
			draw.SetSequentiallyCycledColor(i)
			draw.Quad(t, r, b, l)
			
			// connection rects 
			draw.SetColor(0.0, 0.0, 0.0) // black 
			var ins f32 = 0.05 // inset 
			var ex i32 // exit 
			
			for ex != app.MAX_I32 {
				ex = GetExitAt(i)
				//str.print("GetExitAt")
				//i32.print(j)
				
				if ex == geom.DIR_LEFT {
					draw.Quad(t-ins, r-ins, b+ins, l)
				}else	
				if ex == geom.DIR_RIGHT {
					draw.Quad(t-ins, r,     b+ins, l+ins)
				}else	
				if ex == geom.DIR_DOWN {
					draw.Quad(t-ins, r-ins, b,     l+ins)
				}else	
				if ex == geom.DIR_UP {
					draw.Quad(t,     r-ins, b+ins, l+ins)
				}
			}
		}
	draw.End()
}


func setupPossibleExits () {
	for iY := 0; iY < NumCellsAcross; iY++ {
	for iX := 0; iX < NumCellsAcross; iX++ {
		var r Cell
		
		if iX > 0 {
			r.Exits = append(
			r.Exits, geom.DIR_LEFT)
		}
		
		if iX < i32.sub(NumCellsAcross, 1) {
			r.Exits = append(
			r.Exits, geom.DIR_RIGHT)
		}
		
		if iY > 0 {
			r.Exits = append(
			r.Exits, geom.DIR_DOWN)
		}
		
		if iY < i32.sub(NumCellsAcross, 1) {
			r.Exits = append(
			r.Exits, geom.DIR_UP)
		}
		
		Cells[iY][iX] = r
		//printf("setupPossibleExits() len(r.Exits): %d \n", len(r.Exits))
		////var poss []i32 = Cells[iY][iX].Exits
		////printf("Cells[iY][iX].Exits: %d \n", len(poss))
	}
	}
}


func getRandomCarvedRoom () (x i32, y i32, c Cell, r CarvedRoom) {
	var rnd i32 = i32.rand(0, len(Carvs))
	printf("getRandomCarvedRoom: %d \n", rnd)
	r = Carvs[rnd]
	x = Carvs[rnd].Pos.X
	y = Carvs[rnd].Pos.Y
	c = Cells[y][x]
}


func carveOutConnectedCells () {
	var x i32
	var y i32
	var oc Cell       // older cell 
	var or CarvedRoom // older room 
		
	var numInactives i32 = i32.rand(1, 5)
	str.print("numInactives: ")
	i32.print(numInactives)
	var n i32 = NumCellsAcross * NumCellsAcross - numInactives
	
	for i := 0; i < n; i++ {
		if /* 1st room */ i == 0 {
			// make anywhere 
			x = i32.rand(0, NumCellsAcross)
			y = i32.rand(0, NumCellsAcross)
			var unused CarvedRoom = carveOutRoom(x, y)
		}else{
			x, y, oc, or = getRandomCarvedRoom()
			//printf("carveOutConnectedCells() len(r.Exits): %d \n", len(r.Exits))
			
			for len(oc.Exits) < 1 {
				x, y, oc, or = getRandomCarvedRoom()
			}
			
			// random (exit) id 
			var ri i32 = i32.rand(0, len(oc.Exits))
			var e /* exit */ i32 = oc.Exits[ri]
			var nr CarvedRoom // new room 

			if e == geom.DIR_LEFT {
				nr = carveOutRoom(x-1, y)
				moveExitFromGridCellToRoom(x-1, y,   nr, geom.DIR_RIGHT)
				moveExitFromGridCellToRoom(x,   y,   or, e)
				printf("AFTER DIR_RIGHT moveExitFromGridCellToRoom() - len(OldCell.Exits): %d \n", len(oc.Exits))
			}else			
			if e == geom.DIR_RIGHT {
				nr = carveOutRoom(x+1, y)
				moveExitFromGridCellToRoom(x+1, y,   nr, geom.DIR_LEFT)
				moveExitFromGridCellToRoom(x,   y,   or, e)
				printf("AFTER DIR_LEFT moveExitFromGridCellToRoom() - len(OldCell.Exits): %d \n", len(oc.Exits))
			}else			
			if e == geom.DIR_DOWN {
				nr = carveOutRoom(x, y-1)
				moveExitFromGridCellToRoom(x,   y-1, nr, geom.DIR_UP)
				moveExitFromGridCellToRoom(x,   y,   or, e)
				printf("AFTER DIR_UP moveExitFromGridCellToRoom() - len(OldCell.Exits): %d \n", len(oc.Exits))
			}else			
			if e == geom.DIR_UP {
				nr = carveOutRoom(x, y+1)
				moveExitFromGridCellToRoom(x,   y+1, nr, geom.DIR_DOWN)
				moveExitFromGridCellToRoom(x,   y,   or, e)
				printf("AFTER DIR_DOWN moveExitFromGridCellToRoom() - len(OldCell.Exits): %d \n", len(oc.Exits))
			}
		}
	}
}


func carveOutRoom (x i32, y i32) (out CarvedRoom) {
	out.Pos.X = x
	out.Pos.Y = y
	
	Carvs = append(
	Carvs, out)

	printf("carveOutRoom(%d, %d)   -   len(Carvs): %d \n", x, y, len(Carvs))
}


func moveExitFromGridCellToRoom (x i32, y i32, cr CarvedRoom, dir i32) {
	removeExitFromGrid(x, y, dir)
	cr.Exits = append(
	cr.Exits, dir)
	printf("moveExitFromGridCellToRoom() - len(CarvedRoom.Exits): %d \n", len(cr.Exits))

	var c Cell = Cells[y][x]
	printf("moveExitFromGridCellToRoom() - len(Cell.Exits): %d \n", len(c.Exits))
}


func removeExitFromGrid (x i32, y i32, dir i32) {
	var log bool = true//false
	
	if log { 
		str.print("___________________________________________________________")
		printf("removeExitFromGrid(%d, %d, %s) \n", x, y, getTextForDir(dir))
	}
	
	var c Cell = Cells[y][x]
	// remove from Exits 
	
	if log { printf("------num exits INSIDE-BEFORE: %d \n", len(c.Exits))
	}

	var n i32 = len(c.Exits)
	for i := i32.sub(n, 1); i >= 0; i = i32.sub(i, 1) {
		var s str = getTextForDir(c.Exits[i])
		
		if c.Exits[i] == dir {
			s = str.concat(s, "  <----------------- REMOVING")
			c.Exits = remove(c.Exits, i)
		}
		
		if log { str.print(s)
		}
	}
	
	if log { printf("------num exits INSIDE-AFTER: %d \n", len(c.Exits))
	}
}


func getInversion (dir i32) (out i32) { // (opposite direction) 
	if dir == geom.DIR_LEFT {
		out = geom.DIR_RIGHT
	}else	
	if dir == geom.DIR_RIGHT {
		out = geom.DIR_LEFT
	}else	
	if dir == geom.DIR_DOWN {
		out = geom.DIR_UP
	}else	
	if dir == geom.DIR_UP {
		out = geom.DIR_DOWN
	}
}


func getTextForDir (dir i32) (out str) {
	if dir ==  geom.DIR_LEFT {
		out = "     DIR_LEFT"
	}else	
	if dir ==  geom.DIR_RIGHT {
		out = "     DIR_RIGHT"
	}else	
	if dir ==  geom.DIR_DOWN {
		out = "     DIR_DOWN"
	}else	
	if dir ==  geom.DIR_UP {
		out = "     DIR_UP"
	}
}


func GetNumCarvs () (out i32) {
	out = len(Carvs)
}


func GetGridPos (i i32) (out app.Vec2i) {
	out = Carvs[i].Pos
}


var currExit i32
func GetExitAt (i i32) (out i32) {
	//printf("len(Carvs[i].Exits): %d\n", len(Carvs[i].Exits))
	
	if i < len(Carvs[i].Exits) {
		out = Carvs[i].Exits[currExit]
		currExit++
		i32.print(currExit)
	}else{
		out = app.MAX_I32
		currExit = 0
	}
}