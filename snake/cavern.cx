package cavern



// HMMM
//
// if flying through canyons/caverns/tubes... 
// in center, normal no-gravity-control, but as you get closer to 
// outer edge (edge of obstacles(spikes/stalag[t/m]ites) 
// rather than the "idealized" edge of tube), 
// you get more of a force push towards the center. 
// could give a cool feel of "sliding" 
// against the contours of the spikes? definitely makes it a lot 
// more forgiving against surface contact deaths?  so players can 
// have more fun focusing on the shooting/dodging of asteroids/mobs? 



var NumNodes     i32 = 35
var EndTipLeftX  f32 = -0.15
var EndTipLeftY  f32 = 1.0
var EndTipRightX f32 = 0.15
var EndTipRightY f32 = 1.0


// current node (for generating the path) 
var currNodeId    i32
var cenX          f32 // current center position 
var cenY          f32 = -1.0
var currAim       f32
var currThickness f32 = 0.05 //...extent
// previous node
var prevX         f32 // previous center position 
var prevY         f32
var prevLength    f32



// cache of nodes
// (final world positions/etc.) 

// 		path == centerpoint (& line) between side edges 
var PathX []f32
var PathY []f32

// 		left edge 
var LeftX []f32
var LeftY []f32

// 		right edge 
var RightX []f32
var RightY []f32

// 		...
var Aim         []f32
var Length      []f32
var ThickExtent []f32



func Init() () {
	str.print("--- cavern.Init()")

	for i := 0; i < NumNodes; i++ {
		addNode()
	}



	/*   FIXME:TODO: project endpoint/tip out by this nodes aim & length 
	EndTipLeftX = currY?????
	EndTipLeftY
	EndTipRightX
	EndTipRightY
	*/
}


var prevAim f32
var halfPi  f32 = 1.570796327
func addNode() () {
	aim := 0.0
	len := 0.05

	if /* not root node */ currNodeId != 0 {
		aimChangeGrain := halfPi / 64.0
		aimDelta := i32.f32(i32.rand(-32, 32))
		aimDelta *= aimChangeGrain
		aim = prevAim + aimDelta

		// calc pos from previous node 
		cenX = prevX + f32.sin(aim) * len
		cenY = prevY + f32.cos(aim) * len
	}

	PathX       = []f32.append(PathX, cenX)
	PathY       = []f32.append(PathY, cenY)

	// edges 
	LeftX  = []f32.append(LeftX,  cenX + f32.sin(aim - halfPi) * currThickness)
	LeftY  = []f32.append(LeftY,  cenY + f32.cos(aim - halfPi) * currThickness)
	RightX = []f32.append(RightX, cenX + f32.sin(aim + halfPi) * currThickness)
	RightY = []f32.append(RightY, cenY + f32.cos(aim + halfPi) * currThickness)
	
	Aim         = []f32.append(Aim, aim)
	Length      = []f32.append(Length,      len)
	ThickExtent = []f32.append(ThickExtent, currThickness)




	// final updates 
	prevX      = cenX
	prevY      = cenY
	prevAim    = aim
	prevLength = len
	currNodeId++
	str.print("addED node")
}
