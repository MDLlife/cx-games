package draw

import "gl"
//import "glfw"
import "gltext"

import "entity"
import "game"



var dubPi f32



func Init() () {
	dubPi = 2.0 * 3.141592654
	str.print("--- draw.Init()")
	setupFonts()
}


func All() () {
	Snake()
	Entities()
	Text()
}


func Entities() () {
	// skipping 0 (reserved for player entity), which has it's own draw func. 
	// for now, all else are spheres 
	for i := 1; i < []f32.len(entity.X); i++ {
		//BELOW LINE *SHOULD* WORK but can't seem to write to bool arrays 
		//if []bool.read(entity.Dead, i) == false {
		
		if entity.IsAlive(i) {
			Sphere(
				[]f32.read(entity.X, i), 
				[]f32.read(entity.Y, i), 
				[]f32.read(entity.Rad, i),
				[]f32.read(entity.Red, i), 
				[]f32.read(entity.Green, i), 
				[]f32.read(entity.Blue, i))
		}
	}
}


func Sphere(x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	for i := 0; i < 20; i++ {
		finalX := x + radius * f32.cos(i32.f32(i) * dubPi / 20.0)
		finalY := y + radius * f32.sin(i32.f32(i) * dubPi / 20.0)

		gl.Vertex2f(finalX, finalY)
	}

	gl.End()
}


func Snake() () {
	// start with point A (tip of tail, for the snake) drawn at minimum size. 
	// plot out the remaining spheres.
	// overlapping them by about half their radius.
	// resizing them as we go towards point B (final goal (head of snake) ). 
		
	csis := 0.0 // current spot in spectrum 
	mp /* max progress */ := f64.f32(game.CurrSnakeExtent) * 2.0
	
	

	// head/tail deltas (from center of snake) 
	xOff := f64.f32(game.CurrSnakeExtent * f64.cos(game.CurrSnakeAim))
	yOff := f64.f32(game.CurrSnakeExtent * f64.sin(game.CurrSnakeAim)) 
	
	// tail pos 
	tX := []f32.read(entity.X, 0) - xOff
	tY := []f32.read(entity.Y, 0) - yOff

	// head pos 
	hX := []f32.read(entity.X, 0) + xOff
	hY := []f32.read(entity.Y, 0) + yOff
	


	entity.SetupStringFromPointAToPointB(
		// tail 
		tX, 
		tY, 
		game.TailRadius, 

		// head 
		hX, 
		hY, 
		game.HeadRadius)

	Sphere(entity.BX, entity.BY, game.HeadRadius, 0.0, 0.0, 1.0)



	// draw body 

	for csis <= mp {
		ftd /* fraction towards destination */ := csis / mp
		cRad /* current radius */ := game.TailRadius + ftd * entity.DelRad

		Sphere(
			tX                                       + ftd * entity.DelX, 
			tY                                       + ftd * entity.DelY, 
			cRad, 
			1.0, 1.0, 1.0)

		csis += cRad
	}
}


func Text() () {
	//gl.Color4f(0.5, 0.3, 0.8, 1.0)
	//gltext.Printf("Roboto100", 0.0, 0.0, "Hello World")
	
	EntityText([]f32.read(entity.X, 0), []f32.read(entity.Y, 0), 0.0, 0.0, "mouse + W A S D      5")
}


func EntityText(x f32, y f32, offsetX f32, offsetY f32, s str) () {
	// text space positions 
	midX := i32.f32(game.Width)  / 2.0
	midY := i32.f32(game.Height) / 2.0
	dfc /* distance from center */ := x / game.ScreenBoundsRight
	x := offsetX + midX + midX * dfc
	y := offsetY + i32.f32(game.Height) - (y - game.ScreenBounds.Bottom) * midY

	gl.Color4f(0.8, 0.0, 0.8, 1.0)
	gltext.Printf("Roboto50", x, y, s)
}



// private 

func setupFonts() () {
	wd := os.GetWorkingDirectory()
	fontFile := str.concat(wd, "fonts/roboto-light.ttf")

	os.Open(fontFile)
	gltext.LoadTrueType("Roboto100", fontFile, 100, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)
	
	os.Open(fontFile)
	gltext.LoadTrueType("Roboto50", fontFile, 50, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)

	gl.Enable(gl.DEPTH_TEST)
	gl.DepthFunc(gl.LESS)
	gl.ClearColor(0.1, 0.1, 0.1, 0.0)
}
