package main

import "gl"
import "glfw"
import "gltext"

import "ccInput"
import "game"
import "entity"

var dubPi f32



func main () () {
	dubPi = 2.0 * 3.141592654



	game.Init()
	entity.Init()



	// gl setup

	glfw.Init()
	glfw.CreateWindow("window", game.Width, game.Height, game.Name)
	glfw.MakeContextCurrent("window")
	
	glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
	glfw.SetKeyCallback("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback("window", "onCursorPosEvent")
	
	gl.Init()
	program := gl.CreateProgram()
	gl.LinkProgram(program)



	// font setup

	wd := os.GetWorkingDirectory()
	fontFile := str.concat(wd, "fonts/roboto-light.ttf")

	os.Open(fontFile)
	gltext.LoadTrueType("Roboto100", fontFile, 100, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)
	
	os.Open(fontFile)
	gltext.LoadTrueType("Roboto50", fontFile, 50, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)

	gl.Enable(gl.DEPTH_TEST)
	gl.DepthFunc(gl.LESS)
	gl.ClearColor(0.1, 0.1, 0.1, 0.0)








	var ratio f32

	for !glfw.ShouldClose("window") {
		bufferWidth, bufferHeight := glfw.GetFramebufferSize("window")
		ratio = i32.f32(bufferWidth) / i32.f32(bufferHeight)

		//gl.Clear(gl.COLOR_BUFFER_BIT) // original bouncing-ball sample
		gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

		//gl.UseProgram(program)
		
		gl.MatrixMode(gl.PROJECTION)
		gl.LoadIdentity()
		gl.Ortho(ratio * -1.0, ratio, -1.0, 1.0, 1.0, -1.0)
		gl.MatrixMode(gl.MODELVIEW)

		//respondToCollisions() // ATM, just the left, right, & bottom edge of screen
		updateSnake()
		entity.Update()
		draw()

		glfw.PollEvents()
		glfw.SwapBuffers("window")
	}
}


func onKeyEvent(window str, key i32, scancode i32, action i32, mods i32) () {
	ccInput.OnKeyEvent(window, key, scancode, action, mods)
}


func onMouseButtonEvent(window str, key i32, action i32, mods i32) () {
	if action == glfw.Press {
		Shoot()
	}
}


func onCursorPosEvent(window str, x f64, y f64) () {
	ccInput.OnCursorPosEvent(window, x, y)
}






















//game

func Shoot() () {
	fraction := 0.1
	x := []f32.read(entity.X, 0)
	y := []f32.read(entity.Y, 0) 
	velX := f64.f32(game.CurrSnakeExtent * f64.cos(game.CurrSnakeAim))
	velY := f64.f32(game.CurrSnakeExtent * f64.sin(game.CurrSnakeAim))

	entity.SpawnEntity(x, y, velX, velY,
		0.015, // radius
		glfw.GetTime() + 0.5D) // expiry
}


var velocityInc f32 = 0.001 // increment
var maxVelocity f32 = 0.01
var maxNegativeVelocity f32 = -0.01
func updateSnake() () {
	// tail horizontal motion

	if ccInput.tailMoveLeft {
		[]f32.write(entity.VelX, 0, boundedDecrease([]f32.read(entity.VelX, 0)))
	} 
	
	if ccInput.tailMoveRight {
		[]f32.write(entity.VelX, 0, boundedIncrease([]f32.read(entity.VelX, 0)))
	} 

	if !ccInput.tailMoveLeft && !ccInput.tailMoveRight {
		[]f32.write(entity.VelX, 0, rampDownToStop([]f32.read(entity.VelX, 0)))
	}



	// tail vertical motion

	if ccInput.tailMoveDown {
		[]f32.write(entity.VelY, 0, boundedDecrease([]f32.read(entity.VelY, 0)))
	} 
	
	if ccInput.tailMoveUp {
		[]f32.write(entity.VelY, 0, boundedIncrease([]f32.read(entity.VelY, 0)))
	} 

	if !ccInput.tailMoveUp && !ccInput.tailMoveDown {
		[]f32.write(entity.VelY, 0, rampDownToStop([]f32.read(entity.VelY, 0)))
	}
}


func boundedDecrease(vel f32) (out f32) {
	vel -= velocityInc

	if vel < maxNegativeVelocity {
		vel = maxNegativeVelocity
	}

	return vel
}


func boundedIncrease(vel f32) (out f32) {
	vel += velocityInc

	if vel > maxVelocity {
		vel = maxVelocity
	}

	return vel
}


func rampDownToStop(vel f32) (out f32) {
	if vel > 0.0 {
		vel -= velocityInc

		if vel < 0.0 {
			vel = 0.0
		}
	}

	if vel < 0.0 {
		vel += velocityInc

		if vel > 0.0 {
			vel = 0.0
		}
	}

	return vel
}
























func draw() () {
	drawSnake()
	drawEntities()
	//drawText()
}


func drawSnake() () {
	// ***** HERE IS THE GENERAL IDEA *****
	// (ACTUAL DETAILS ARE LOSSY BECAUSE WE DON'T NEED A PRECISE AMOUNT OF SPHERE OVERLAPPING)
	
	// start with tip of tail (drawn at minimum size), then space out the
	// remaining spheres (increasing in size as we progress to the head) 
	// overlapping them by approximately half their radius
	
	/* progress along snake length */
	pasl := 0.0
	/* max progress */
	mp := f64.f32(game.CurrSnakeExtent) * 2.0
	
	xOff := f64.f32(game.CurrSnakeExtent * f64.cos(game.CurrSnakeAim))
	yOff := f64.f32(game.CurrSnakeExtent * f64.sin(game.CurrSnakeAim)) 
	
	// tail 
	tX := []f32.read(entity.X, 0) - xOff
	tY := []f32.read(entity.Y, 0) - yOff
	
	// head
	hX := []f32.read(entity.X, 0) + xOff
	hY := []f32.read(entity.Y, 0) + yOff
		
	
	// draw line connecting head to tail	

	cr := /* current */ game.TailRadius
	radDelta /* from tail radius to increased head radius */ := game.HeadRadius - cr
	hoftX /* head offset from tail */ := hX - tX
	hoftY /* head offset from tail */ := hY - tY

	for pasl <= mp {
		drawBall(tX, tY, /* 0.005 */ cr, 1.0, 1.0, 1.0)

		fracSamp /* fractional sample point */ := pasl / mp
		tX += fracSamp * hoftX 
		tY += fracSamp * hoftY
		cr += fracSamp * radDelta



		pasl += cr

	}



	// tail		0.025, //radius
	// head		0.05,  //radius
}


func drawEntities() () {
	for i := 0; i < []f32.len(entity.X); i++ {
		if []bool.read(entity.Dead, i) == false {
			drawBall(
				[]f32.read(entity.X, i), 
				[]f32.read(entity.Y, i), 
				[]f32.read(entity.Rad, i),
				[]f32.read(entity.Red, i), 
				[]f32.read(entity.Green, i), 
				[]f32.read(entity.Blue, i))
		}
	}
}


func drawText() () {
	//gl.Color4f(0.5, 0.3, 0.8, 1.0)
	//gltext.Printf("Roboto100", 0.0, 0.0, "Hello World")
	
	drawEntityText([]f32.read(entity.X, 0), []f32.read(entity.Y, 0), 0.0, 0.0, "W")
}


func drawEntityText(x f32, y f32, offsetX f32, offsetY f32, s str) () {
	// text space positions 
	midX := i32.f32(game.Width)  / 2.0
	midY := i32.f32(game.Height) / 2.0
	dfc /* distance from center */ := x / game.ScreenBoundsRight
	x := offsetX + midX + midX * dfc
	y := offsetY + i32.f32(game.Height) - (y - game.ScreenBounds.Bottom) * midY

	gl.Color4f(0.8, 0.0, 0.8, 1.0)
	gltext.Printf("Roboto50", x, y, s)
}


func drawBall(x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	for i := 0; i < 20; i++ {
		finalX := x + radius * f32.cos(i32.f32(i) * dubPi / 20.0)
		finalY := y + radius * f32.sin(i32.f32(i) * dubPi / 20.0)

		gl.Vertex2f(finalX, finalY)
	}

	gl.End()
}
