package draw

import "gl"
import "gltext"
import "os"

import "app"
import "map"
import "shape"



var PicBackground i32
var PicStar       i32
var PicShapeTile  i32



func Init () {
	str.print("draw.Init ()")
	
	wd := os.GetWorkingDirectory()
	
	// pics 
	PicBackground = gl.NewTexture(str.concat(wd, "assets/textures/background.jpg"))
	PicStar       = gl.NewTexture(str.concat(wd, "assets/textures/star.png"))
	PicShapeTile  = gl.NewTexture(str.concat(wd, "assets/textures/tile.png"))

	// font 
	fontFile := str.concat(wd, "assets/fonts/roboto-light.ttf")
	os.Open(fontFile)
	gltext.LoadTrueType("Roboto50", fontFile, 50, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)
}


func PicAtScale (picId i32, x f32, y f32, scaleX f32, scaleY f32) {
	gl.LoadIdentity()
	gl.Translatef(x, y, 0.0)
	
	// only diff
	
	gl.BindTexture(gl.TEXTURE_2D, picId)
	gl.Scalef(scaleX, scaleY, 0.0)
	
	gl.Begin(gl.QUADS)
		gl.TexCoord2d(0.0D, 0.0D)
		gl.Vertex3f(-1.0, 1.0, 0.0)
		
		gl.TexCoord2d(1.0D, 0.0D)
		gl.Vertex3f(1.0, 1.0, 0.0)
		
		gl.TexCoord2d(1.0D, 1.0D)
		gl.Vertex3f(1.0, -1.0, 0.0)
		
		gl.TexCoord2d(0.0D, 1.0D)
		gl.Vertex3f(-1.0, -1.0, 0.0)
	gl.End()
}


func PlayField () {
	var fX f32 = map.LEdge + map.CellWidthHalf
	var fY f32 = -0.95 + map.CellHeightHalf

	for y := 0; y < map.NUM_CELLS_Y; y++ {
		for x := 0; x < map.NUM_CELLS_X; x++ {
			var c i32 = map.Cells[y][x]

			if c == map.EMPTY_CELL {
				c = 0
			}
			
			gl.Color3f(
				app.Colors[c].R, 
				app.Colors[c].G, 
				app.Colors[c].B)
			
			PicAtScale(
				PicShapeTile, 
				f32.add(fX, f32.mul(i32.f32(x), map.CellWidth)),
				f32.add(fY, f32.mul(i32.f32(y), map.CellHeight)), 
				map.CellWidthHalf, 
				map.CellHeightHalf)
		}
	}
}


func PlayerPiece () {
	var i i32 = i32.add(shape.PlayerShape, 1)
	gl.Color3f(
		app.Colors[i].R, 
		app.Colors[i].G, 
		app.Colors[i].B)
	
	var fX f32 = map.LEdge + map.CellWidthHalf
	var fY f32 = -0.95 + map.CellHeightHalf

	for y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			if shape.Cells[shape.PlayerShape][shape.PlayerFacing][y][x] {
				PicAtScale(
					PicShapeTile, 
					f32.add(fX, f32.mul(i32.f32(x - 2 + shape.PlayerPos.X), map.CellWidth)),
					f32.add(fY, f32.mul(i32.f32(y - 2 + shape.PlayerPos.Y), map.CellHeight)), 
					map.CellWidthHalf, 
					map.CellHeightHalf)
			}
		}
	}
}


func NextShape () {
	var i i32 = i32.add(shape.Next, 1)
	gl.Color3f(
		app.Colors[i].R, 
		app.Colors[i].G, 
		app.Colors[i].B)
	
	// setup sizes to fit box 
	var num i32 = getLargestNumCellsAcross()
	
	var spanX  f32 = map.CellWidth
	var spanY  f32 = map.CellHeight
	var scaleX f32 = f32.div(map.CellWidth,  i32.f32(num))
	var scaleY f32 = f32.div(map.CellHeight, i32.f32(num))

	// center of next-shape box 0.71, 0.51 
	var fX f32 = 0.71
	var fY f32 = 0.51
	
	//for y := 0; y < 5; y++ {
		//for x := 0; x < 5; x++ {
			
		
			//if shape.Cells[shape.Next][shape.FACING_UP][y][x] {
				PicAtScale(
					PicShapeTile, 
					fX, //f32.add(fX, f32.mul(i32.f32(x), spanX)),
					fY, //f32.add(fY, f32.mul(i32.f32(y), spanY)), 
					scaleX, 
					scaleY)
			//}
		//}
	//}
}



func getLargestNumCellsAcross () (out i32) {
	var ex i32 
	
	ex = shape.Extents[shape.Next][shape.FACING_UP][shape.FACING_UP] +
		 shape.Extents[shape.Next][shape.FACING_UP][shape.FACING_DOWN]
		 
	if out < ex {
		out = ex
	}

	ex = shape.Extents[shape.Next][shape.FACING_UP][shape.FACING_LEFT] +
		 shape.Extents[shape.Next][shape.FACING_UP][shape.FACING_RIGHT]
		 
	if out < ex {
		out = ex
	}
	
	out = i32.add(out, 1)
	//str.print("__________________________________________________")
	//i32.print(out)
}