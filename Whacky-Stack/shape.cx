package shape

import "app"
import "map"



var NUM_SHAPES i32 = 7 // (4 of them are mirrored) 

var SHAPE_BEAM i32
var SHAPE_L i32
var SHAPE_L_MIRROR i32
var SHAPE_ZIGZAG i32
var SHAPE_ZAGZIG i32
var SHAPE_MIDTINE i32
var SHAPE_BLOCK i32

type Shape struct {
	Cells [5][5]bool
}

// shapes occupy a 5x5 grid of cells 
// 0,0 is the bottom left corner, same as map/playfield cells 
// extents are how many cells go out from the center (2,2) 
var UpExtent    i32
var RightExtent i32
var DownExtent  i32
var LeftExtent  i32
var Cells [5][5]bool
var rp    [5][5]bool // rotated piece (temp scratchpad) 
//var Curr Shape

// FIXME:  
//		do pos initialization each time new piece starts at top
var PlayerPos Vec2I = Vec2I{ X: 4, Y: map.NUM_CELLS_Y - 1 }


func Setup () {
	str.print("shape.Setup ()")
	init(//Curr,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0)
}


func MovePieceBy (x i32, y i32) {
	// FIXME: 
	// ensure within side edges
	// LOCK (and spawn new piece) when touching bottom, or other blocks) 
	
	// flesh out MovePieceBy(), to do each tween of jump 
	
	PlayerPos.X = i32.add(PlayerPos.X, x)
	
	//DownExtent
	if /* going down */ y < 0 &&
		PlayerPos.Y > 0 + DownExtent {
		
		PlayerPos.Y = i32.add(PlayerPos.Y, y)
	} else
	if /* going up */ y > 0 &&
		PlayerPos.Y < map.NUM_CELLS_Y - 1 - UpExtent {
		
		PlayerPos.Y = i32.add(PlayerPos.Y, y)
	}
}


// i wanted to input the values of pieces in a visual way 
// (via a grid of 0s & 1s)
// even tho in the end i wanted bool values.  
// this converts i32 to bool 
func getBoolSetExtents (y i32, x i32, i i32) (out bool) {
	if i != 0 {
		out = true
	
		x = i32.sub(x, 2)
		y = i32.sub(y, 2)
		
		if x < 0 {
			x = i32.abs(x)

			if LeftExtent < x {
				LeftExtent = x
			}
		} else
		if x > 0 {
			if RightExtent < x {
				RightExtent = x
			}
		}
		
		if y < 0 {
			y = i32.abs(y)
			
			if DownExtent < y {
				DownExtent = y
			}
		} else
		if y > 0 {
			if UpExtent < y {
				UpExtent = y
			}
		}
	}
}


func init (//foo Shape,
	a i32, b i32, c i32, d i32, e i32,
	f i32, g i32, h i32, i i32, j i32,
	k i32, l i32, m i32, n i32, o i32,
	p i32, q i32, r i32, s i32, t i32,
	u i32, v i32, w i32, x i32, y i32) {
	
	str.print("shape.init ()")
	
	Cells[0][0] = getBoolSetExtents(0, 0, u)
	Cells[0][1] = getBoolSetExtents(0, 1, v)
	Cells[0][2] = getBoolSetExtents(0, 2, w)
	Cells[0][3] = getBoolSetExtents(0, 3, x)
	Cells[0][4] = getBoolSetExtents(0, 4, y)
	
	Cells[1][0] = getBoolSetExtents(1, 0, p)
	Cells[1][1] = getBoolSetExtents(1, 1, q)
	Cells[1][2] = getBoolSetExtents(1, 2, r)
	Cells[1][3] = getBoolSetExtents(1, 3, s)
	Cells[1][4] = getBoolSetExtents(1, 4, t)
	
	Cells[2][0] = getBoolSetExtents(2, 0, k)
	Cells[2][1] = getBoolSetExtents(2, 1, l)
	Cells[2][2] = getBoolSetExtents(2, 2, m)
	Cells[2][3] = getBoolSetExtents(2, 3, n)
	Cells[2][4] = getBoolSetExtents(2, 4, o)
	
	Cells[3][0] = getBoolSetExtents(3, 0, f)
	Cells[3][1] = getBoolSetExtents(3, 1, g)
	Cells[3][2] = getBoolSetExtents(3, 2, h)
	Cells[3][3] = getBoolSetExtents(3, 3, i)
	Cells[3][4] = getBoolSetExtents(3, 4, j)
	
	Cells[4][0] = getBoolSetExtents(4, 0, a)
	Cells[4][1] = getBoolSetExtents(4, 1, b)
	Cells[4][2] = getBoolSetExtents(4, 2, c)
	Cells[4][3] = getBoolSetExtents(4, 3, d)
	Cells[4][4] = getBoolSetExtents(4, 4, e)
	
	showEdges()
}


// this rotates the top towards the left (CCW) 
func Rotate () { // j = the y in rp 
	var up i32 = UpExtent
	
	UpExtent = RightExtent
	RightExtent = DownExtent
	DownExtent = LeftExtent
	LeftExtent = up

	j := 4
	for y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			rp[x][j] = Cells[y][x]
		}
		
		j--	
	}
	
	Cells = rp
	showEdges()
}


func showEdges () {
	str.print("-----------------------------------------------")
	printf("UpExtent   : %d \n", UpExtent)
	printf("RightExtent: %d \n", RightExtent)
	printf("DownExtent : %d \n", DownExtent)
	printf("LeftExtent : %d \n", LeftExtent)
}
