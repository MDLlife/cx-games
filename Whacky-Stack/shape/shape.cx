package shape

import "app"
import "map"



var SHAPE_BEAM     i32
var SHAPE_L        i32 = 1
var SHAPE_L_MIRROR i32 = 2
var SHAPE_ZIGZAG   i32 = 3
var SHAPE_ZAGZIG   i32 = 4
var SHAPE_MIDTINE  i32 = 5
var SHAPE_CUBE     i32 = 6
var SHAPE_MAX      i32 = 7

var FACING_UP    i32
var FACING_RIGHT i32 = 1
var FACING_DOWN  i32 = 2
var FACING_LEFT  i32 = 3
var FACING_MAX   i32 = 4

var Next i32

//type Shape struct { FIXME: ATM CX can't do multidimensional arrays/slices inside a struct 
	// shapes/pieces occupy a 5x5 grid of cells 
	// 1st 2 indexes are SHAPE_MAX, then FACING_MAX, so we can store all rotations of all pieces 
	// 0,0 (in the last 2 indexes) is the bottom left corner, same as map/playfield cells 
	var Cells [7][4][5][5]bool // player piece    FIXME?: ATM CX can't handle "constants" as array sizes 
	// extents are how many cells go out from the center (2,2) 
	var Extents [7][4][4]i32
//}

var PlayerPos    Vec2I
var PlayerFacing i32
var PlayerShape  i32
var PlayerScore  i32


func Init () {		
	str.print("shape.Init ()")
	setupAllShapes()	
	map.EmptyPlayfield()
	
	// fill playfield with random blocks 
	for y := 0; y < map.NUM_CELLS_Y - 8; y++ {
		for x := 0; x < map.NUM_CELLS_X; x++ {
			if i32.rand(0, 2) == 0 {
				map.Cells[y][x] = i32.rand(0, SHAPE_MAX)
			}
		}
	}
			 
	Next = i32.rand(0, SHAPE_MAX)
 	spawnNew()
}


func setupAllShapes () {
	setupAllPossibleRotations(
		SHAPE_BEAM,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		1, 1, 1, 1, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0)
	
	setupAllPossibleRotations(
		SHAPE_L,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 1, 0, 0, 0,
		0, 0, 0, 0, 0)
		/*
		0, 0, 0, 0, 0,
		0, 1, 0, 0, 0,
		0, 1, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0)
		*/
	
	setupAllPossibleRotations(
		SHAPE_L_MIRROR,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 0, 0)
		/*
		0, 0, 0, 0, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 1, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0)
		*/
	
	setupAllPossibleRotations(
		SHAPE_ZIGZAG,
		0, 0, 0, 0, 0,
		0, 1, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0)
		/*
		0, 0, 0, 0, 0,
		0, 1, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 0, 0)
		*/
	
	setupAllPossibleRotations(
		SHAPE_ZAGZIG,
		0, 0, 0, 0, 0,
		0, 0, 0, 1, 0,
		0, 0, 1, 1, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0)
		/*
		0, 0, 0, 0, 0,
		0, 0, 0, 1, 0,
		0, 1, 1, 1, 0,
		0, 1, 0, 0, 0,
		0, 0, 0, 0, 0)
		*/
	
	setupAllPossibleRotations(
		SHAPE_MIDTINE,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0)
	
	setupAllPossibleRotations(
		SHAPE_CUBE,
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0)
		/*
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 1, 1, 1, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0)
		*/
}


func PlayerRotate(change i32) {
	if PlayerShape == SHAPE_CUBE {
		return
	}
	
	if PlayerShape == SHAPE_BEAM ||
		PlayerShape == SHAPE_ZIGZAG ||
		PlayerShape == SHAPE_ZAGZIG {
		
		if PlayerFacing == FACING_UP {
			if enoughCellsOpenForNextPosition(0, 0, FACING_RIGHT) {
				PlayerFacing = FACING_RIGHT
			}
			
			return		
		} else if PlayerFacing == FACING_RIGHT {
			if enoughCellsOpenForNextPosition(0, 0, FACING_UP) {
				PlayerFacing = FACING_UP
			}
			
			return		
		}
	}
	

	var wantedFacing i32 = i32.add(PlayerFacing, change)
	
	if wantedFacing >= FACING_MAX {
		wantedFacing = FACING_UP
	}
	
	if wantedFacing < FACING_UP {
		wantedFacing = FACING_LEFT
	}

	if enoughCellsOpenForNextPosition(0, 0, wantedFacing) {
		PlayerFacing = wantedFacing
	} else {
		// TODO: 
		// WOULD BE NICE TO BE ABLE TO PLAY A BZZZZT / ERROR SOUND HERE
		// but we could print red text saying something 
	}
}


func MovePieceBy (x i32, y i32) {
	// FIXME: 
	// flesh out MovePieceBy(), to do each tween of jump? 
	// if we add shortcut to instazoom down to the bottom 
	// (triggering that could call this with an x,y 
	// change/offset greater than 1) it needs to check
	// for collision for each +/- 1 step 	
	
	if /* going left */ x < 0 &&
		PlayerPos.X > 0 + Extents[PlayerShape][PlayerFacing][FACING_LEFT] && 
		enoughCellsOpenForNextPosition(x, y, PlayerFacing) {
		
		PlayerPos.X = i32.add(PlayerPos.X, x)
	} else
	if /* going right */ x > 0 &&
		PlayerPos.X < map.NUM_CELLS_X - 1 - Extents[PlayerShape][PlayerFacing][FACING_RIGHT] &&
		enoughCellsOpenForNextPosition(x, y, PlayerFacing) {
		
		PlayerPos.X = i32.add(PlayerPos.X, x)
	}
	
	if /* going down */ y < 0 {
		if PlayerPos.Y > 0 + Extents[PlayerShape][PlayerFacing][FACING_DOWN] {
			if enoughCellsOpenForNextPosition(x, y, PlayerFacing) {
				PlayerPos.Y = i32.add(PlayerPos.Y, y)
			}else{
				freezeShape()
			}
		} else {
			freezeShape()
		}
	} else
	if /* going up */ y > 0 &&
		PlayerPos.Y < map.NUM_CELLS_Y - 1 - Extents[PlayerShape][PlayerFacing][FACING_UP] {
		
		PlayerPos.Y = i32.add(PlayerPos.Y, y)
	}
}


func enoughCellsOpenForNextPosition (xOff i32, yOff i32, facing i32) (out bool) {
	out = true
	
	for y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			if Cells[PlayerShape][facing][y][x] {
				var mY i32 = PlayerPos.Y - 2 + y + yOff
				var mX i32 = PlayerPos.X - 2 + x + xOff
				
				//printf("mX, mY: %d, %d \n", mX, mY)
				
				if mX < 0 ||
					mX >= map.NUM_CELLS_X ||
					mY < 0 ||
					mY >= map.NUM_CELLS_Y {
					
					out = false
					return
				}
				
				if map.Cells[mY][mX] != map.EMPTY_CELL {
					out = false
				}
			}
		}
	}
}


func freezeShape () {
	str.print("-----------------------------freezeShape()")
	
	for y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			if Cells[PlayerShape][PlayerFacing][y][x] {
				map.Cells[PlayerPos.Y - 2 + y][PlayerPos.X - 2 + x] = PlayerShape
			}
		}
	}
	
	// collapse full rows & change score 
	var numRowsFilled i32
	var start i32 = i32.sub(PlayerPos.Y, Extents[PlayerShape][PlayerFacing][FACING_DOWN])
	var end   i32 = i32.add(PlayerPos.Y, Extents[PlayerShape][PlayerFacing][FACING_UP])
	for y := start; y <= end; y++ {
		//printf("y: %d, end: %d \n", y, end)
		
		var rowFull bool = true
			
		for x := 0; bool.and(rowFull, x < map.NUM_CELLS_X); x++ {
			//printf("x: %d \n", x)
			
			if map.Cells[y][x] == map.EMPTY_CELL {
				rowFull = false
			}
		}
		
		//str.print("if rowFull")
		
		if rowFull {
			numRowsFilled = i32.add(numRowsFilled, 1)
		
			// shift all-rows-above down by one 
			for j := i32.add(y, 1); j < map.NUM_CELLS_Y; j++ {
				for i := 0; i < map.NUM_CELLS_X; i++ {
					var lj i32 = i32.sub(j, 1) // lesser j 
					map.Cells[lj][i] =	
					map.Cells[j][i]
				
					if /* on the top row */ j == i32.sub(map.NUM_CELLS_Y, 1) {
						map.Cells[j][i] = map.EMPTY_CELL // clear row 
					}
				}
			}
			
			// upper rows shifted down, 
			// go back 1 to prevent skipping 2 consecutive filled rows 
			y = i32.sub(y, 1) 
		}
	}
	
	if numRowsFilled > 0 {
		// TODO work out combo multipliers 
		
		/*
		if numRowsFilled >= 4 {
		
		} else
		if numRowsFilled >= 4 {
		
		} else
		if numRowsFilled >= 4 {
		
		} else
		if numRowsFilled >= 4 {
		
		} else
		*/
		
		var delta i32 = i32.pow(numRowsFilled, numRowsFilled)
		
		PlayerScore = i32.add(PlayerScore, delta)
		printf("+ %d    SCORE: %d \n", delta, PlayerScore)
	}
	
	spawnNew()
}


func spawnNew () {
	PlayerFacing = 0
	PlayerShape  = Next
	Next         = i32.rand(0, SHAPE_MAX)
	setupSizesAndOffsetsForNext()
	
	var i i32 = Extents[PlayerShape][PlayerFacing][FACING_UP] + 1
	PlayerPos = Vec2I{ X: 4, Y: map.NUM_CELLS_Y - i }
}


// i wanted to input the values of pieces in a visual way 
// (via a grid of 0s & 1s)
// even tho in the end they will be bool values.  
// this converts i32 to bool 
func getBoolAndSetExtents (y i32, x i32, i i32, shape i32) (out bool) {
	if i != 0 {
		out = true
	
		x = i32.sub(x, 2)
		y = i32.sub(y, 2)
		
		if x < 0 {
			x = i32.abs(x)

			if Extents[shape][0][FACING_LEFT] < x {
				Extents[shape][0][FACING_LEFT] = x
			}
		} else
		if x > 0 {
			if Extents[shape][0][FACING_RIGHT] < x {
				Extents[shape][0][FACING_RIGHT] = x
			}
		}
		
		if y < 0 {
			y = i32.abs(y)
			
			if Extents[shape][0][FACING_DOWN] < y {
				Extents[shape][0][FACING_DOWN] = y
			}
		} else
		if y > 0 {
			if Extents[shape][0][FACING_UP] < y {
				Extents[shape][0][FACING_UP] = y
			}
		}
	}
}


func setupAllPossibleRotations (shape i32,
	a i32, b i32, c i32, d i32, e i32,
	f i32, g i32, h i32, i i32, j i32,
	k i32, l i32, m i32, n i32, o i32,
	p i32, q i32, r i32, s i32, t i32,
	u i32, v i32, w i32, x i32, y i32) {
	
	Cells[shape][0][0][0] = getBoolAndSetExtents(0, 0, u, shape)
	Cells[shape][0][0][1] = getBoolAndSetExtents(0, 1, v, shape)
	Cells[shape][0][0][2] = getBoolAndSetExtents(0, 2, w, shape)
	Cells[shape][0][0][3] = getBoolAndSetExtents(0, 3, x, shape)
	Cells[shape][0][0][4] = getBoolAndSetExtents(0, 4, y, shape)
	
	Cells[shape][0][1][0] = getBoolAndSetExtents(1, 0, p, shape)
	Cells[shape][0][1][1] = getBoolAndSetExtents(1, 1, q, shape)
	Cells[shape][0][1][2] = getBoolAndSetExtents(1, 2, r, shape)
	Cells[shape][0][1][3] = getBoolAndSetExtents(1, 3, s, shape)
	Cells[shape][0][1][4] = getBoolAndSetExtents(1, 4, t, shape)
	
	Cells[shape][0][2][0] = getBoolAndSetExtents(2, 0, k, shape)
	Cells[shape][0][2][1] = getBoolAndSetExtents(2, 1, l, shape)
	Cells[shape][0][2][2] = getBoolAndSetExtents(2, 2, m, shape)
	Cells[shape][0][2][3] = getBoolAndSetExtents(2, 3, n, shape)
	Cells[shape][0][2][4] = getBoolAndSetExtents(2, 4, o, shape)
	
	Cells[shape][0][3][0] = getBoolAndSetExtents(3, 0, f, shape)
	Cells[shape][0][3][1] = getBoolAndSetExtents(3, 1, g, shape)
	Cells[shape][0][3][2] = getBoolAndSetExtents(3, 2, h, shape)
	Cells[shape][0][3][3] = getBoolAndSetExtents(3, 3, i, shape)
	Cells[shape][0][3][4] = getBoolAndSetExtents(3, 4, j, shape)
	
	Cells[shape][0][4][0] = getBoolAndSetExtents(4, 0, a, shape)
	Cells[shape][0][4][1] = getBoolAndSetExtents(4, 1, b, shape)
	Cells[shape][0][4][2] = getBoolAndSetExtents(4, 2, c, shape)
	Cells[shape][0][4][3] = getBoolAndSetExtents(4, 3, d, shape)
	Cells[shape][0][4][4] = getBoolAndSetExtents(4, 4, e, shape)
	
	//showExtents(FACING_UP)
	
	rotate(shape, FACING_LEFT)
	rotate(shape, FACING_DOWN)
	rotate(shape, FACING_RIGHT)
}


// this rotates the top towards the left (CCW) 
func rotate (shape i32, newFacing i32) {
	var oldFacing i32 = newFacing + 1
	
	if oldFacing >= FACING_MAX {
		oldFacing = FACING_UP
	}
	
	Extents[shape][newFacing][FACING_UP] = Extents[shape][oldFacing][FACING_RIGHT]
	Extents[shape][newFacing][FACING_RIGHT] = Extents[shape][oldFacing][FACING_DOWN]
	Extents[shape][newFacing][FACING_DOWN] = Extents[shape][oldFacing][FACING_LEFT]
	Extents[shape][newFacing][FACING_LEFT] = Extents[shape][oldFacing][FACING_UP]

	j := 4 // the y in new grid 
	for y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			Cells[shape][newFacing][x][j] = 
			Cells[shape][oldFacing][y][x]
		}
		
		j--	
	}
	
	//showExtents(newFacing)
}


func showExtents (facing i32) {
	str.print("------------------------show extents-----------------------")
	printf("UpExtent   : %d \n", Extents[PlayerShape][facing][FACING_UP])
	printf("RightExtent: %d \n", Extents[PlayerShape][facing][FACING_RIGHT])
	printf("DownExtent : %d \n", Extents[PlayerShape][facing][FACING_DOWN])
	printf("LeftExtent : %d \n", Extents[PlayerShape][facing][FACING_LEFT])
}
