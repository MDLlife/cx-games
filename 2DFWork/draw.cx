package draw

import "gl"

import "app"
import "entities"
import "geom"
import "map"



func Ball (ball entities.Ball) {
	var x f32
	var y f32

	gl.Begin(gl.POLYGON)
	gl.Color3f(1.0, 1.0, 1.0)

	var i f32
	for i = 0.0; f32.lt(i, 20.0); i = f32.add(i, 1.0) {
		x = f32.add(ball.x, f32.mul(ball.radius, f32.cos(f32.div(f32.mul(i, geom.TAU), 20.0))))
		y = f32.add(ball.y, f32.mul(ball.radius, f32.sin(f32.div(f32.mul(i, geom.TAU), 20.0))))

		gl.Vertex2f(x, y)
	}

	gl.End()
}



func Rects () {
	var x f32
	var y f32

	gl.Begin(gl.QUADS)
		var n i32 = map.GetNumCarvs()
		//printf("murrr: %d \n", n)
		for i := 0; i < n; i++ {
			var p app.Vec2i = map.GetGridPos(i)
			var mulX f32 = f32.mul(i32.f32(p.X), map.CellSpan)
			var mulY f32 = f32.mul(i32.f32(p.Y), map.CellSpan)
			
			var b f32 = f32.add(-1.0, mulY)
			var l f32 = f32.add(-1.0, mulX)
			var t f32 = b + map.CellSpan
			var r f32 = l + map.CellSpan
			
			SetSequentiallyCycledColor(i)
			rect(t, r, b, l)
			
			// connection rects 
			gl.Color3f(0.0, 0.0, 0.0) // black 
			var ins f32 = 0.05 // inset 
			var ex i32 // exit 
			
			for ex != app.MAX_I32 {
				ex = map.GetExitAt(i)
				//str.print("map.GetExitAt")
				//i32.print(j)
				
				if ex == geom.DIR_LEFT {
					rect(t-ins, r-ins, b+ins, l)
				}else	
				if ex == geom.DIR_RIGHT {
					rect(t-ins, r,     b+ins, l+ins)
				}else	
				if ex == geom.DIR_DOWN {
					rect(t-ins, r-ins, b,     l+ins)
				}else	
				if ex == geom.DIR_UP {
					rect(t,     r-ins, b+ins, l+ins)
				}
			}
		}
	gl.End()
}


// top, right, bottom, left 
func rect (t f32, r f32, b f32, l f32) {
	gl.Vertex2f(l, t)
	gl.Vertex2f(r, t)
	gl.Vertex2f(r, b)
	gl.Vertex2f(l, b)
}


func SetSequentiallyCycledColor (i i32) {
	var l i32 = len(app.Colors)
	var c i32 = i % l
	
	gl.Color3f(
		app.Colors[c].R,
		app.Colors[c].G,
		app.Colors[c].B)
}